<h3 class="centered">Drab.Query</h3>
<h4 class="centered">
  The jQuery in Elixir
</h4>


<div class="row">
  <div class="col-md-12">
    <p>
      <img src="<%= static_path(@conn, "/images/drab-logo-200.png")%>" class="drab-logo" alt="pipe-shaped slingshot" title="pipe-shaped slingshot">
      This part of the tutorial is based on the <code>Drab.Query</code> module, which is an elixir interface to <code>jQuery</code>. Most of the examples are similar to the main page, but all of them requires <code>Drab.Query</code> enabled nad <code>jQuery</code> installed.
    </p>
    <p>
      In general, <code>Drab.Query</code> treats the client browser as a database provider and gives the way to <code>select</code>, <code>update</code>, <code>insert</code> and <code>delete</code> objects or object attributes:
    <pre><code class="elixir"><%=~s/select(something, from: selector)
insert(something, into: selector)
delete(selector) or delete(something, from: selector)
update(something, set: new_value, on: selector)/%></code></pre>
    </p>

  </div>

</div>

<hr>

<div class="row">
  <a name="simple">
    <h4 class="anchored">Simple Input and Button Example</h4>
  </a>
  <div class="col-md-8">
    <p>Here is the simplest example  - text input and the button. Clicking the button make input text uppercase. Awesome!</p>
    <p>
      On the <b>client side</b> we have a basic HTML with the input and the button:
<pre><code class="html"><%=~s(<input id="text_to_uppercase" value="uppercase me">
<button drab="click:uppercase">Do it</button>)%></code></pre>
    </p>
    <p>
      The only thing which might be considered new is a <code>drab="click:uppercase"</code> attribute. What do this value mean? <code>click</code> is obviously a name of the event, and <code>uppercase</code> is a name of the <b>Elixir function on the server side</b>, in <code>DrabPoc.PageCommander</code> module (see the code below). Clicking on the <code>&lt;button&gt;</code> <b>in the browser</b> runs <code>DrabPoc.PageCommander.uppercase/2</code> <b>on the server.</b>
<pre><code class="elixir"><%=~s{defmodule DrabPoc.PageCommander do
  use Drab.Commander, modules: [Drab.Query, Drab.Modal, Drab.Waiter]
  defhandler uppercase(socket, sender) do
    t = socket |> select(:val, from: "#text_to_uppercase")
    socket |> update(:val, set: String.upcase(t), on: "#text_to_uppercase")
  end
end}%></code></pre>
    <p>
      How does it work? <code>Drab.Query.select(socket, :val, from: "#text_to_uppercase")</code> launches jQuery <code>$("#text_to_uppercase").val()</code> on the client side and returns it to the server. Then, the returned string is converted to uppercase using <code>String.upcase</code> and passed to <code>Drab.Query.update/3</code> function, which - analogically to jQuery <code>.val(value)</code> - sets the value of the input.
    </p>
    <p>
      There is a number of jQuery methods mapped to <code>Drab.Query.Select</code> - like <code>:html</code>, <code>:attr</code>, etc. They all behave exactly like their jQuery equivalent - for example, <code>Drab.Query.select(:html, ...)</code> returns String with html of the first found DOM object. But what if you want to get html of all DOM object found? It is still possible with Drab - you just need to use the <strong>plural version</strong> of the method (<code>:htmls</code> instead of <code>:html</code>). This is going to return a map of all DOM object found, where key is the object name or id (or special string "__undefined_[number]", if neither name or id found) and the value is the return value of the method you run. <br>
      Below is the example of using both versions of <code>select(:val)</code> methods. Singular one just returns String, while plural - a Map with all found DOM objects processed.
    </p>
<pre><code class="elixir"><%=~S/name = socket |> select(:val, from: "#name")
# "Zdzisław"
name = socket |> select(:vals, from: "input")
# %{"name" => "Zdzisław", "surname" => "Dyrma"}/%></code></pre>
    <p>
      All the Drab functions (callbacks, event handlers) are placed in the module called Commander. Think about  it as a Controller for the living page. Commander must have a corresponding controller (because the page to command must be rendered before), in this example PageCommander corresponds to PageController.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      This is a live demo. Click the button to launch <code>DrabPoc.QueryCommander.uppercase/2</code> on the server.
      <br><br>
      <input class="form-control" id="text_to_uppercase" value="uppercase me">
      <button class="btn btn-primary" id="uppercase_button" drab="click:uppercase">Do it</button>
    </p>
  </div>
</div>

<hr>



<div class="row">
  <a name="dom_sender">
    <h4 class="anchored">Access to the Sender DOM Object Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      The next example shows how we can retrieve the information from <code>data</code> attribute. We've simple set up few buttons, each with the same event function <code>clicked_sleep_button</code>:
      <pre><code class="html"><%=~s(<button drab-click="clicked_sleep_button" data-sleep="1">Sleep 1 second</button>
<button drab-click="clicked_sleep_button" data-sleep="2">Sleep 2 seconds</button>
<button drab-click="clicked_sleep_button" data-sleep="3">Sleep 3 seconds</button>)%></code></pre>
    Did you notice <code>drab-click</code> attribute? This is a alternative way for <code>drab="event:handler"</code>. There is a number of such shorthands for most popular events, see documentation for more.
    </p>
    <p>
      On the server side the code is not very sophisticated as well. The whole functionality is to sleep for a few seconds. But the sleep interval is given with <code>data</code> property in <code>dom_sender</code> variable. Please notice that this variable contains more interesting values to be used, like <code>val</code>, <code>html</code> or <code>text</code>.
      <pre><code class="elixir"><%=~s/defhandler clicked_sleep_button(socket, dom_sender) do
  socket |> update(class: "btn-primary", set: "btn-danger", on: this(dom_sender))
  :timer.sleep(dom_sender["data"]["sleep"] * 1000)
  socket |> update(class: "btn-danger", set: "btn-primary", on: this(dom_sender))
end/%></code></pre>
      With this example we introduce <code>this/1</code> function, which allows you to operate on the DOM object in similar way as with <code>$(this)</code> in JS. This is a way to use one event handler for multiple objects.
    </p>
    <p>
      Observe that when one button is "processing", you can click another one. This is because <strong>Drab requests are asynchronous on the server side</strong>. And this is a reason why buttons are disabled by default while processing - it is blocking the user from running the same action for few times. You may override this behaviour in `config.exs` with:
      <pre><code class="elixir"><%=~s/config :drab, disable_controls_while_processing: false/%></code></pre>
    </p>
  </div>
  <div class="col-md-4 left-bordered">
    <p>
      Click the button to launch sleep <br><br>
      <button drab-click="clicked_sleep_button" class="btn btn-primary" data-sleep="1">Sleep 1 second</button><br><br>
      <button drab-click="clicked_sleep_button" class="btn btn-primary" data-sleep="2">Sleep 2 seconds</button><br><br>
      <button drab-click="clicked_sleep_button" class="btn btn-primary" data-sleep="3">Sleep 3 seconds</button><br><br>
    </p>
  </div>
</div>
<hr>


<div class="row">
  <a name="tens_of_processes">
    <h4 class="anchored">Tens of Tasks Running in Parallel on the Server and Communicating Back to the Browser</h4>
  </a>
  <div class="col-md-8">
    <p>
      In the next example we will emulate long running server Process composed of a number of Tasks, which can be run asynchronously. We want to run it in parallel, change their status when they finish the job and - when all of them are done - change the status of the whole process.
    </p>
    <p>
      HTML side contains button and few DIVs which displays the status of the process and tasks:
<pre><code class="html"><%=~s(Async task status:
<span id="async_task_status" class="label label-primary">
  ready
</span>
<span class="task label label-danger" data-task_id="1">Task 1</span>
  ...
<span class="task label label-danger" data-task_id="54">Task 54</span>
<button drab-click="run_async_tasks">Start async task</button>)%></code></pre>
    </p>
    <p>
      The whole processing is on the server side. Clicking the button runs <code>run_async_tasks/2</code> function on the server side:
<pre><code class="elixir"><%=~s/defhandler run_async_tasks(socket, dom_sender) do
  socket
    |> update(class: "label-success", set: "label-danger", on: ".task")
    |> update(:text, set: "running", on: "#async_task_status")

  tasks = Enum.map(1..54, fn(i) -> Task.async(fn ->
    :timer.sleep(:rand.uniform(4000)) # simulate real work
    socket |> update(class: "label-danger", set: "label-success", on: ".task[data-task_id=#\{i\}]")
    end)
  end)
  Enum.each(tasks, fn(task) -> Task.await(task) end)

  socket |> update(:html,
    set: "finished",
    on: "#async_task_status")
end/%></code></pre>
    The code above runs asynchronously 54 Tasks, which just wait some time (up to 4 seconds) and then communicate to the user by changing the boostrap class from <code>label-danger</code> to <code>label-success</code>. After launching the background tasks, it waits (<code>Task.await/1</code>) for all of the tasks to finish and then informs the user by changing the Task status to "finished".
    </p>
    <p>
      You may think: <b>what is the difference between this approach and running 54 AJAX requests which launches action on the controller side?</b> Well, except of <code>Drab</code> natural beauty, you can't do it with AJAX. You browser <a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">limits the number of simultaneus connections</a>.
    </p>
  </div>
  <div class="col-md-4 left-bordered">
    <p>
      Click the button below to simulate server-side long running process contains asynchronous tasks.
      <h4>Async task status: <span id="async_task_status" class="label label-primary">ready</span></h4>
      <div class="row">
        <%= for i <- 1..54 do %>
          <div class="col-md-2 col-xs-4 centered">
            <span class="task label label-danger" data-task_id="<%= i %>">Task #<%= i |> Integer.to_string |> String.pad_leading(2, "0") %></span>
          </div>
        <% end %>
      </div>
      <br>
      <button class="btn btn-primary" drab-click="run_async_tasks">Start async task</button>
    </p>
  </div>
</div>
<hr>


<div class="row">
  <a name="long_running">
    <h4 class="anchored">Long Running Process with Communication Back to Browser</h4>
  </a>
  <div class="col-md-8">
    <p>
      Let's move to some more complicated functionality. Assume having a process which is doing some stuff on the server side and we want to report back to the user after each completed step. We will use the progress bar controlled from the server. <br>
      Client side is very simple, again. Please notice the <code>drab-click</code> attribute - this time it will run <code>perform_long_process</code> function on the server side.
<pre><code class="html"><%=~s[<div class="progress">
  <div class="progress-bar" role="progressbar" style="width:0%">
  </div>
</div>
<button drab-click="perform_long_process">Click me to start processing ...</button>]%></code></pre>
      On the server we simulate a long processing by sleeping some random time in each step. We will run <code>start_background_process</code> function. Main loop runs random number of steps, and each step just sleeps for a random time. After the nap, <code>update_bar</code> function in launched and sets the <code>css("width")</code> of the <code>progress-bar</code> to <code>XX%</code> and then, the html of the progress bar node to <code>"XX%"</code>. We keep it doing it until it reaches 100%, then we <code>insert(class: "progress-bar-success", into: ".progress-bar")</code>. Lets repeat this code in English: <strong>insert</strong> the <strong>class</strong> <em>progress-bar-success</em> <strong>into</strong> the <em>.progress-bar</em> selector. This is why I prefer the pipe syntax - Drab functions are more readable with it.
      <br>
      Notice that updates can be stacked, because all Drab setter functions return <code>socket</code>.
<pre><code class="elixir"><%=~S"""
  defhandler perform_long_process(socket, dom_sender) do
    socket
      |> execute(:hide, on: this(dom_sender))
      |> insert(cancel_button(socket, self()), after: "[drab-click=perform_long_process]")
    start_background_process(socket)
  end

  defp start_background_process(socket) do
    socket |> delete(class: "progress-bar-success", from: ".progress-bar")
    steps = :rand.uniform(100)
    step(socket, steps, 0)
  end

  defp step(socket, last_step, last_step) do
    # last step, when number of steps == current step
    update_bar(socket, last_step, last_step)
    socket |> insert(class: "progress-bar-success", into: ".progress-bar")
    case socket |> alert("Finished!", "Do you want to retry?", buttons: [ok: "Yes", cancel: "No!"]) do
      {:ok, _} -> start_background_process(socket)
      {:cancel, _} -> clean_up(socket)
    end
  end

  defp step(socket, steps, i) do
    :timer.sleep(:rand.uniform(500)) # simulate real work
    update_bar(socket, steps, i)
    step(socket, steps, i + 1)
  end

  defp update_bar(socket, steps, i) do
    socket
      |> update(css: "width", set: "#{i * 100 / steps}%", on: ".progress-bar")
      |> update(:html, set: "#{Float.round(i * 100 / steps, 2)}%", on: ".progress-bar")
  end
  """%></code></pre>
      Just before running the background process, the event handler (<code>perform_long_process/2</code> function) hides the main button (<code>execute(:hide, on: this(dom_sender)</code>) and then adds the Cancel button to the DOM tree with <code>insert("button html", after: "[drab-click=perform_long_process])"</code>. Translating it to English again, it means <strong>insert</strong> <em>button html</em> <strong>after</strong> <em>all objects having <strong>drab-click=perform_long_process</strong></em> properties. This shows the Cancel button, defined here:
    </p>
<p>
<pre><code class="elixir"><%=~S[defp cancel_button(socket, pid) do
  """
  <button class="btn btn-danger"
          drab-click="cancel_long_process"
          data-pid="#{Drab.tokenize_pid(socket, pid)}">
    Cancel
  </button>
  """
end]%></code></pre>
  This function builds the simple button html to be inserted into the DOM tree. What is interesting here, is that button has its event handler (function <code>cancel_long_process/2</code>) and <code>data-pid</code> property, containing the PID of the Elixir process which runs the steps loop (in this case it is <code>self()</code>). This is because we need to know which process to cancel!
  <br>
  Tokenizing the PID prevents data tampering (and also translates Elixir PID to String, so it could be inserted into the DOM tree). Remember that Tokens are signed, but not encrypted, so do not store any sensitive data in this way.
</p>
<p>
To be able to cancel the process we need to modify <code>step/3</code> to receive notifications from the outside world. In our case, in each step system checks if there is a message to cancel process. In this case it cleans the stuff up, and finish. If there is no message like this, immediatel (<code>after 0</code>) continues the loop.
<pre><code class="elixir"><%=~S/defp step(socket, steps, i) do
  :timer.sleep(:rand.uniform(500)) # simulate real work
  update_bar(socket, steps, i)
  # wait for a cancel message
  receive do
    :cancel_processing ->
      clean_up(socket)
  after 0 ->
    step(socket, steps, i + 1)
  end
end

defhandler cancel_long_process(socket, dom_sender) do
  pid = Drab.detokenize_pid(socket, dom_sender["data"]["pid"])
  send(pid, :cancel_processing)
end
/%></code></pre>
In the cancel button handler, you just need to get the tokenized pid from <code>dom_sender["data"]["pid"]</code> and decrypt it with <code>Drab.detokenize_pid/2</code> function. Then send it a gentle message asking for not to continue.

</p>
    <p>
      Now take a look on <code>Drab.Modal.alert/4</code> - the function which shows the bootstrap modal window on the browser and waits for the user input. Please notice that nothing is updated until you close the alert box. And because you can put your own form in the alert box, this is the easiest way to get the user input. Alert boxes return not only the name of the clicked button, but as well the names and values of all inputs in the modal window.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    Click a button to simulate long-running process on the server.
    <div class="progress">
      <div class="progress-bar" role="progressbar" style="width:0%">
      </div>
    </div>
    <button class="btn btn-primary" drab-click="perform_long_process">Click me to start processing ...</button>
  </div>
</div>
<hr>



<div class="row">
  <a name="tail_dash_f">
    <h4 class="anchored">Server-Side Events: Display the Growing File (tail -F)</h4>
  </a>
  <div class="col-md-8">
    <p>
      Another great example of Drab usage is to display the files, which are changing over the time, like log files. In the normal, Ajax world, you need to send a request periodically to refresh the view, and you never know, if the file changed or not. What a waste of resouces!
    </p>
    <p>
      With Drab, you can utilize the events on the Server Side: in this case to use <code>fsevent</code> to trace the changes in the file. So you upgrade the UI view only in case when something really happened.
    </p>
    <p>
      To enable the Server-Side event watcher, we are going to introduce the Drab Callbacks. Callbacks are events launched automatically, when page is loaded, when browser reconnects or disconnects from the Server. To enable it you need to specify them in the Commander:
<pre><code class="elixir"><%=~s/use Drab.Commander, modules: [Drab.Query, Drab.Modal, Drab.Waiter]
onconnect :connected/%></code></pre>
      <code>onconnect</code> launches every time client connects to the server, so after first load, network crashes, server crashes etc. There is also <code>onload</code> callback, which runs only once and ignores disconnects.
    </p>
    <p>
      In the handler function we subscribe to <code>Sentix</code> file watcher (it is a wrapper around <code>fswatch</code> utility):
<pre><code class="elixir"><%=~s/def connected(socket) do
  clean_up(socket)

  # Sentix is already started within application supervisor
  Sentix.subscribe(:access_log)

  file_change_loop(socket, Application.get_env(:drab_poc, :watch_file))
end/%></code></pre>
      Watcher sends a message each time the file change. In this case we are going to update the <code>#log_file</code> div to present the last few lines of the file.
<pre><code class="elixir"><%=~s/defp file_change_loop(socket, file_path) do
  receive do
    {_pid, {:fswatch, :file_event}, {^file_path, _opts}} ->
      socket |> update(:text, set: last_n_lines(file_path, 10), on: "#log_file")
  end
  file_change_loop(socket, file_path)
end/%></code></pre>
    </p>
    <p>
      There is also the <code>disconnect</code> callback, which runs every time browser disconnects from the server - close the browser, navigate away from the page, network issue, etc. Obviously there is no way to show it on the Demo page, as it operates when the page is not visible anymore. In the example above, you may use it to terminate the <code>file_change_loop</code>.
    </p>
  </div>
  <div class="col-md-4 left-bordered">
    <p>
      This is a realtime view of few last lines of the access.log of this page
      <pre><code id="log_file" class="accesslog">
... this pane will update when access.log change ...
      </code></pre>
    </p>
  </div>
</div>
<hr>



<div class="row">
  <a name="broadcast">
    <h4 class="anchored">Is Drab Quick Enough? Plus Broadcast</h4>
  </a>

  <div class="col-md-8">
    <p>
      You may concern about Drab performance - is it quick enough to handle events in the realtime? The best to find it out is to check - lets say the <code>keyup</code> event.
      <pre><code class="html"><%=~s(<input drab-keyup="changed_input" data-update="#display_placeholder">
<div id="display_placeholder"></div>)%></code></pre>
      <pre><code class="elixir"><%=~s/defhandler changed_input(socket, dom_sender) do
  socket |> update!(:text,
                 set: String.upcase(dom_sender["val"],
                  on: dom_sender["data"]["update"])
end/%></code></pre>
    </p>
    <p>
      Did you notice the <code>update!/2</code> (with bang!) function? This one works exactly like <code>update/2</code>, but it <strong>broadcasts to all the browsers</strong> on which the current page is opened. Open another browser window or even another browser and observe what is going on when you type in. <br>
      By default, broadcasts are sent to the displayers of the current page, but you may change this behaviour by setting up <code>broadcasting</code> option in the Commander. For example, setting <code>broadcasting :same_controller</code> will send this <code>update!</code> to all browsers which have opened the pages generated in the current controller.
    </p>
  </div>
  <div class="col-md-4 left-bordered">
    <p>
      Demonstration of <code>keyup</code> event:
      <input drab-keyup="changed_input" class="form-control" data-update="#display_placeholder">
      <div id="display_placeholder"></div>
    </p>
  </div>

  <div class="col-md-8">
    <p>
      In many situation you don't need to react on every single key press, and you want to launch the event when user stop typing. The good example is autocomplete - you don't want to search the database after each keypress. This is the are where <code>debounce()</code> option becomes handy:
      <pre><code class="html"><%=~s[<input drab-keyup="changed_input"
       drab-options="debounce(500)"
       data-update="#display_placeholder2">
<div id="display_placeholder">Some text here</div>]%></code></pre>
      The code above is exactly the same as previous, except of <code>debounce(500)</code> option. The same event handler (<code>changed_input/2</code>) is launched, but not after every key up, but when you actually stop typing for 500 miliseconds.
    </p>
  </div>
  <div class="col-md-4 left-bordered">
    <p>
      The same event with <code>debounce(500)</code>:
      <input drab-keyup="changed_input" drab-options="debounce(500)" data-update="#display_placeholder2" class="form-control">
      <div id="display_placeholder2"></div>
    </p>
  </div>

</div>
<hr>



<div class="row">
  <a name="store">
    <h4 class="anchored">Drab Store and access to Plug Session</h4>
  </a>
  <div class="col-md-12">
    <p>
      Analogically to Plug, Drab can store the values in its own session. To avoid confusion with the session, we will call it a Drab Store. You can use two functions, <code>put_store/3</code> and <code>get_store/2</code> to read and write the values in the Store. It works exactly the same as a "normal", Phoenix session.
      <ul>
        <li>By default, Drab Store is kept in browser Local Storage. This means it is gone when you close the browser or the tab. You may set up where to keep the data with <code>drab_store_storage</code> config entry.</li>
        <li>Drab Store is not the Plug Session! This is a different entity. Anyway, you have an access to the Plug Session (details below).</li>
        <li>Drab Store is stored on the client side and it is signed, but - as the Plug Session cookie - not ciphered.</li>
      </ul>
    </p>
  </div>
  <div class="col-md-8">
    <p><pre><code class="elixir"><%=~S/defhandler increase_counter(socket, _dom_sender) do
  counter = get_store(socket, :counter) || 0
  put_store(socket, :counter, counter + 1)
end

defhandler show_counter(socket, _dom_sender) do
  counter = get_store(socket, :counter)
  socket |> alert("Counter", "Counter value: #{counter}")
  socket
end/%></code></pre>
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <button class="btn btn-primary" drab-click="increase_counter">Increase counter by 1</button><br><br>
      <button class="btn btn-primary" drab-click="show_counter">Show the counter value</button>
    </p>
  </div>

  <div class="col-md-8">
    <p>
    Although Drab Store is a different entity than Plug Session (used in Controllers), there is a way to access the Session. First, you need to whitelist the keys you wan to access in <code>access_session/1</code> macro (you may give it a list of atoms or a single atom). Whitelisting is due to security: it is kept in Token, on the client side, so it is signed but not encrypted. <br>

    To show an example, we've put the key <code>:drab_test</code> to the Plug Session while rendering this page by the Controller:
    <pre><code class="elixir"><%=~S/defmodule DrabPoc.PageController do
  use DrabPoc.Web, :controller
  use Drab.Controller

  def index(conn, _params) do
    conn = put_session(conn, :drab_test, "test string in Plug Session, set in the Controller")
    render conn, "index.html"
  end
end/%></code></pre>
    To use it in the Commander, you need to explicitly inherit this value:
<pre><code class="elixir"><%=~S/defmodule DrabPoc.PageCommander do
  use Drab.Commander, modules: [Drab.Query, Drab.Modal, Drab.Waiter]

  onload :page_loaded,
  access_session :drab_test

  def page_loaded(socket) do
    socket
    |> update(:val, set: get_session(socket, :drab_test), on: "#show_session_test")
  end
end/%></code></pre>
    Notice that there is not way to update session from Drab. Session is read-only.
    </p>
  </div>
  <div class="col-md-4 left-bordered">
    <p>
      Result of <code>get_session(socket, :drab_test)</code> in the <code>onload</code> handler: <br>
      <input type="text" id="show_session_test" value="unknown..." class="form-control">
    </p>
  </div>

</div>
<hr>



<div class="row">
  <a name="chat_example">
    <h4 class="anchored">Chat Example</h4>
  </a>
  <div class="col-md-8">
    Is there any websocket based library without the Chat Example? Here is the one based on Drab! Simplest Chat Ever (and, well, the most primitive one). <br>
    The client-side contains chat <code>div</code> to display messages, and two <code>input</code> fields - one for your nick, and the second one for the chat message:
    <p><pre><code class="html"><%=~S[<div id="chat"></div>
<input drab-change="update_nick" class="form-control" placeholder="nickname">
<input drab-change="update_chat" class="form-control">]%></code></pre>
    </p>
    <p>
      On the Elixir side, <code>update_nick</code> event handler saves your nickname for the future use:
      <pre><code class="elixir"><%=~S/defhandler update_nick(socket, sender), do: socket |> put_store(:nickname, sender["val"])/%></code></pre>
    </p>
    <p>
      The following code is the whole chat application! We retrieve the nickname from the Drab Store (or set it to <i>Anonymous</i> if not found), compose the message to be displayed, and we are ready to go. First, we insert the message to the chat panel (used the <code>append</code> method, so it is added at the bottom of the chat div). Second, clean up the message input. Third, scroll down chat to the bottom. All the changes of are broadcasted to all browsers viewing this page, because we used bang versions of functions here.
      <pre><code class="elixir">defhandler update_chat(socket, sender) do
  nick = get_store(socket, :nickname, &quot;Anonymous&quot;)
  html = ~E&quot;&lt;strong&gt;&lt;%= nick %&gt;:&lt;/strong&gt; &lt;%= message %&gt;&lt;br&gt;&quot; |&gt; safe_to_string()
  socket
    |&gt; insert!(html, append: &quot;#chat&quot;)
    |&gt; update(:val, set: &quot;&quot;, on: this(sender))
    |&gt; execute!(&quot;animate({scrollTop: $('#chat').prop('scrollHeight')}, 500)&quot;, on: &quot;#chat&quot;)
end</code></pre>
      The only new thing is the <code>execute!</code> function. This is the simplest of all Drab.Query functions: it just runs given jQuery method on the selector.
    </p>
    <p>So far, chat just displays the message when someone type it in. It would also nice to have some additional information, like the time when the message appeared. This is quite complicated feature - we can't just display the server time, as users may go from the different timezones. Drab has a build-in function <code>Drab.Browser.now/1</code> function, which gives the <strong>client local time</strong>:
      <pre><code class="elixir"><%=~S/iex> Drab.Browser.now(socket)
~N[2017-04-02 20:06:07.600000]
/%></code></pre>
    but we can't use it here, as we are broadcasting messages to all connected browsers.
    </p>
    <p>
      The solution is to use a bit of Javascript (sic!). Instead of adding the message to chat window with <code>socket |> insert!(html, append: "#chat")</code>, we directly will run the JS on all connected browsers!
      <pre><code class="elixir">defp chat_message_js(message) do
  &quot;&quot;&quot;
  var time = &quot;[&quot; + (new Date()).toTimeString().substring(0, 5) + &quot;] &quot;
  $('#chat').append(time + #{message |&gt; Drab.Core.encode_js})
  &quot;&quot;&quot;
end

defp add_chat_message!(socket, message) do
  socket |&gt; broadcast_js(chat_message_js(message))
  socket |&gt; scroll_down!()
end

defhandler update_chat(socket, sender) do
  nick = get_store(socket, :nickname, &quot;Anonymous&quot;)
  html = ~E&quot;&lt;strong&gt;&lt;%= nick %&gt;:&lt;/strong&gt; &lt;%= message %&gt;&lt;br&gt;&quot; |&gt; safe_to_string()
  socket
    |&gt; update(:val, set: &quot;&quot;, on: this(sender))
    |&gt; add_chat_message!(html)
end</code></pre>
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <div class="panel panel-default">
        <div class="panel-heading">The Chat</div>
        <div id="chat" class="panel-body chat-panel">
        </div>
        <div class="panel-footer">
          <div class="row">
            <div class="col-xs-3 no-right-padding">
              <input id="nickname" drab-change="update_nick" class="form-control no-right-radius" placeholder="nickname">
            </div>
            <div class="col-xs-9 no-left-padding">
              <input drab-change="update_chat" class="form-control no-left-radius">
            </div>
          </div>
        </div>
      </div>
    </p>
  </div>

</div>
<hr>


<div class="row">
  <a name="presence">
    <h4 class="anchored">Tracking connected users with Drab callbacks</h4>
  </a>
  <div class="col-md-8">
    <p>
      You probably realized that actual chat is a little bit more complicated then it was explained in the previous example. It shows users connects and disconnects, as well as the list of connected users (type in <code>/who</code> in the chat to see the list). To archive it, we are going to use Drab callbacks, defined with <code>onconnect/1</code> and <code>ondisconnect/1</code> macros. Again, please treat it only as an example of Drab features - there are better ways to tracking the presence in Phoenix.
      <pre><code class="elixir">def connected(socket) do
  nickname = get_store(socket, :nickname, &quot;Anonymous&quot;)
  joined = ~E&quot;&quot;&quot;
    &lt;span class='chat-system-message'&gt;*** &lt;b&gt;&lt;%= nickname %&gt;&lt;/b&gt; has joined the chat.&lt;/span&gt;&lt;br&gt;
    &quot;&quot;&quot; |&gt; safe_to_string()
  socket |&gt; add_chat_message!(joined)

  ref = make_ref()
  DrabPoc.Presence.add_user(ref, nickname)
  put_store(socket, :my_drab_ref, Drab.pid(socket))
end</code></pre>
    The code above is executed every time your browser connects to the server. First, we broadcasts the information about user connected to the chat. Second, we store the information about connected user in the special store, <code>DrabPoc.Presence</code>. It is just a simple <code>Agent</code>, which stores key/value pairs. It is out of the scope of this tutorial, but if you are interested how it works, read <a href="https://github.com/grych/drab-poc/blob/master/lib/drab_poc/presence.ex">the helpful source</a>.
    </p>
    <p>
      We are going to use a reference as a key, which will be stored on the client side with the Drab Store. We are going to need it while handling disconnects.
    </p>
    <p>
      Let's move to the disconnect handler. As you probably guess, it is executed when the browser disconnects from the server. It may be because of navigate away from the page, close the tab or because of the network issues. Disconnect handler is different than the others - it does not receive the <code>socket</code> as an argument. It is beacuse the <code>socket</code> does not exist anymore! But we still have an access to Drab Store and Drab Session:
      <pre><code class="elixir">def disconnected(store, session) do
  DrabPoc.Presence.remove_user(store[:my_drab_ref])
  removed_user = store[:nickname] || anon_with_country_code(session[:country_code])
  html = ~E&quot;*** &lt;%= removed_user %&gt; has left.&lt;br&gt;&quot; |&gt; safe_to_string()
  add_chat_message!(same_controller(DrabPoc.PageController), html)
  update_presence_list!(same_controller(DrabPoc.PageController))
end</code></pre>
      We are going to use the Drab Store to retrieve the user's nickname, and the Drab process PID (remember, it was set previously in <code>onconnect</code> handler). First, we need to remove the connection information from the presence list. We could finish here, but it would be good to inform all other users that this guy is gone. But how to broadcast the message, when the <code>socket</code> does not exist anymore?
    </p>
    <p>
      Drab's broadcasting functions can live without socket. Socket is needed only to find out to which browser send a message (so event handlers in Commander know which browser pressed a button). Broadcasts are just pushed into a void and being received by all the browsers, which currently listen to the given topic. Because we set up the commander with <code>broadcasting :same_controller</code>, we can send the broadcast to <code>same_controller(Controller.Name)</code> instead of the socket.
    </p>
    <p>
      As a bonus, we've got the list of connected users. Let's use it and do a live list of all the people currently connected to this page. First, create a function to update the panel on the right:
      <pre><code class="elixir">defp update_presence_list!(topic) do
  users = DrabPoc.Presence.get_users()
    |&gt; Map.values()
    |&gt; Enum.sort()
    |&gt; Enum.map(&amp;html_escape/1)
    |&gt; Enum.map(&amp;safe_to_string/1)
    |&gt; Enum.join(&quot;&lt;br&gt;&quot;)
  topic |&gt; update!(:html, set: users, on: &quot;#presence-list&quot;)
end</code></pre>
      Second, run this function on connect, disconnect or nickname change. Voila!
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <div class="panel panel-default">
        <div class="panel-heading">Connected users</div>
        <div id="presence-list" class="panel-body chat-panel">
        </div>
      </div>
    </p>
  </div>

</div>
<hr>



<div class="row">
  <a name="waiter">
    <h4 class="anchored">Drab Waiter</h4>
  </a>
  <div class="col-md-12">
    <p>
      Sometimes it would be good to have a possibility to ask user about something, when you are in a middle of some process, and you don't want to finish your function. The good example is a <strong>database transaction, when you run some query and want to ask user wheter commit or rollback changes</strong>. We saw the use of <code>Drab.Modal</code> before, but sometimes modal window is not very elegant.
    </p>
    <p>
      So the solution for this issue is called <strong>Drab Waiter</strong>. It is a tiny little DSL which stops processing the event handler function and waits for the event from the client side. You may register multiple events as well as a timeout (by default it is waiting forever). The example below is not very sophisticated, but shows the idea.
    </p>
  </div>
  <div class="col-md-8">
    <p><pre><code class="elixir"><%=~S/  defhandler waiter_example(socket, _dom_sender) do
    buttons = Phoenix.View.render_to_string(DrabPoc.PageView, "waiter_example.html", [])
    socket
      |> delete(from: "#waiter_answer_div")
      |> insert(buttons, append: "#waiter_example_div")

    answer = waiter(socket) do
      on "#waiter_example_div button", "click", fn(sender) ->
        sender["text"]
      end
      on_timeout 5000, fn ->
        "six times nine"
      end
    end

    socket
      |> delete(from: "#waiter_example_div")
      |> update(:text, set: "Do you realy think it is #{answer}?", on: "#waiter_answer_div")
  end/%></code></pre>
      Please notice that <em>Waiter Example</em> button is disabled until you give an answer (or until timeout). It is because Drab re-enables it when Event Handler Function finish processing.
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <button class="btn btn-primary" drab-click="waiter_example">Waiter Example</button>
      <br><br>
      <div id="waiter_answer_div"></div>
      <div id="waiter_example_div"></div>
    </p>
  </div>

</div>
<hr>





<div class="row">
  <a name="errors">
    <h4 class="anchored">Handling Errors and Exceptions</h4>
  </a>
  <div class="col-md-12">
    <p>
      Drab intercepts all exceptions from event handler function and let it die, but before it presents the error message in the logs, and, for development environment, on the page. For production, it shows just an alert with the generic error. <br>
      Please notice that an error in the specific handler function will not harm anything else: all the processing are going on normally.
    </p>
  </div>
  <div class="col-md-8">
    <p>
    <pre><code class="elixir"><%=~S|defhandler raise_error(_socket, _dom_sender) do
  map = %{x: 1, y: 2}
  # the following line will cause KeyError
  map.z
end|%></code></pre>
    By default it is just an <code>alert()</code>, but you can easly override it by creating the template in <code>priv/templates/drab/drab.handler_error.prod.js</code> with your own javascript presenting the error.
    </p>
    <p>
    There is much descriptive message in the logs. The same message is shown within the alert on development environment.
    <pre><code class="text"><%=~S|[error] Drab Handler failed with the following exception:
** (KeyError) key :z not found in: %{x: 1, y: 2}
    (drab_poc) web/commanders/page_commander.ex:183: DrabPoc.PageCommander.raise_error/2
    lib/drab.ex:178: anonymous fn/5 in Drab.handle_event/6|%></code></pre>
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <button class="btn btn-primary" drab-click="raise_error">KABOOM!</button>
    </p>
  </div>

  <div class="col-md-8">
    <p>
    But what when the Handler Process is killed for some other, than the exception, reason - like being brutally murdered? The story is quite similar - we can show the error banner, but in this case there is no way to clean up. In practice the button will stay disabled.
    <pre><code class="elixir"><%=~S|defhandler self_kill(_socket, _dom_sender) do
  Process.exit(self(), :kill)
end|%></code></pre>
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <button class="btn btn-primary" drab-click="self_kill">Commit Suicide</button>
    </p>
  </div>
</div>
<hr>



<div class="row">
  <a name="debugging">
    <h4 class="anchored">Debugging</h4>
  </a>
  <div class="col-md-12">
    <p>
      There is an easy way to check and debug Drab functions directly in the <code>IEx</code>. The only you need to do is to run your Drab-enabled phoenix server (you can get one with pre-installed Phoenix and Drab from <a href="https://github.com/grych/drab-example">https://github.com/grych/drab-example</a>) with IEx: <code>iex -S mix phoenix.server</code>. Then, connect with the browser to <code>http://localhost:4000</code> and observe the IEx console. When started, Drab will show you some important debugging information:
      <pre><code class="text"><%=~S{[debug]
    Started Drab for /drab, handling events in DrabPoc.PageCommander
    You may debug Drab functions in IEx by copy/paste the following:
import Drab.Core; import Drab.Query; import Drab.Modal; import Drab.Waiter
socket = GenServer.call(pid("0.663.0"), :get_socket)

    Examples:
socket |> select(:htmls, from: "h4")
socket |> exec_js("alert('hello from IEx!')")
socket |> alert("Title", "Sure?", buttons: [ok: "Azaliż", cancel: "Poniechaj"])
}%></code></pre>
    </p>
    <p>
      As suggested, copy those two lines into IEx and now you can remote control your browser from IEx. Very handy for learning Drab and debugging!
      <pre><code class="elixir"><%=~S'iex(1)> import Drab.Core; import Drab.Query; import Drab.Modal; import Drab.Waiter
Drab.Waiter
iex(2)> socket = GenServer.call(pid("0.663.0"), :get_socket)
%Phoenix.Socket{assigns: %{__action: :index,
   __controller: DrabPoc.PageController, __drab_pid: #PID<0.663.0>,
   ...
   transport_pid: #PID<0.1548.0>}

iex(3)> socket |> select(:htmls, from: "h4")
%{"__undefined_0" => "\n  The jQuery in Elixir\n",
  "__undefined_1" => "Async task status: <span id=\"async_task_status\" class=\"label label-primary\">ready</span>",
  "__undefined_2" => "\n  ©2016 Tomek \"Grych\" Gryszkiewicz, <a href=\"mailto:grych@tg.pl\">grych@tg.pl</a>\n",
...
  "tail_dash_f" => "Server-Side Events: Display the Growing File (tail -F)",
  "tens_of_processes" => "Tens of Tasks Running in Parallel on the Server and Communicating Back to the Browser",
  "waiter" => "Drab Waiter"}
'%></code></pre>
    </p>
    <p>
      Please be aware that Drab creates its own process for every single connection, so if you open a page in multiple tabs or browsers, you will have to handle with few different Drab PIDs. Also watch out for automatic page reload after code change - this will re-launch Drab as well, it will change its PID.
    </p>
  </div>
</div>
<hr>

<h4>
  &copy;2016 - 2018 Tomek "Grych" Gryszkiewicz, <a href="mailto:grych@tg.pl">grych@tg.pl</a>
</h4>
<hr>
