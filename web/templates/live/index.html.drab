<h3 class="centered">Drab - Access the User Interface in browser from the Server Side</h3>
<h4 class="centered">
  Living EEx Pages in Phoenix
</h4>

<div class="row">

  <div class="col-md-8">
    <p>
      <img src="<%= static_path(@conn, "/images/drab-logo-200.png")%>" class="drab-logo" alt="pipe-shaped slingshot" title="pipe-shaped slingshot">
      In the <i>"good old times"</i> the event handling was easy. The only thing you had to do was to create the event handler (remember <code>TForm1.Button1Click(Sender: TObject)</code>?) and you could do everything inside this handler: accessing data from models, manipulating user interface, sending raw Ethernet packets to the coffee machine...
    </p>
    <p>
      Nowadays, when the most of the applications are web based, it is not so easy anymore. You need either to create a form and submit the data via POST or GET or use AJAX to send or retrieve data. Whole interface manipulation is on the client side. In practice, you need to write two applications: on the client and the server side.  
    </p>
    <p>
      Additionally, because <code>http</code> is stateless and a one-way protocol, it is not easy to communicate back from the server to the browser. Like, for example, during execution of the long running process, when there is a need to update status (eg. progress bar), or to ask the operator about something (like "would you like to continue?"). Of course there are workarounds for this, like polling the server every few seconds to have a status, or even auto-refreshing the page, but those are just a dirty workarounds. The solution would be to allow an access to the interface directly from the server side. And here comes <code>Drab</code>.
    </p>
    <p>
      <code>Drab</code> is a concept of <b>providing an access to User Interface (DOM objects) on the server side</b>, just like in the 
      good-old Delphi times. The examples below should give you an overview of how does it work. For more detailed instructions, please refer to the <a href="https://hexdocs.pm/drab">documentation</a>.
    </p>
    <p>
      Drab is written using <strong>Phoenix on Elixir</strong>, so all the code in examples is HTML and Elixir. <b>This page is a living demo - all examples are actually working on the Drab server</b>.
      You can find a source code of this page <a href="https://github.com/grych/drab-poc">on Github</a>, and the <a href="https://github.com/grych/drab">source code of the Drab himself - here</a>.
    </p>
    <p><small>&copy; <a href="mailto:grych@tg.pl">Tomek "Grych" Gryszkiewicz</a> 2016 - 2017</small></p>
    <iframe src="https://ghbtns.com/github-btn.html?user=grych&repo=drab&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe><br>
    <iframe src="https://ghbtns.com/github-btn.html?user=grych&repo=drab&type=watch&count=true&v=2" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>
  </div>



  <div class="col-md-4 left-bordered">
    <div class="panel panel-default">
      <div class="panel-heading">v0.4.0 improves reliability <span class="label label-default">2017-05-16</span></div>
      <div class="panel-body">
        <p>
          <a href="https://github.com/grych/drab/releases/tag/v0.4.0">This version</a> introduces redesigned API for the most essential part of Drab API: <code>Drab.Core</code>. <code>execjs</code> and <code>broadcastjs</code> has been depreciated in favor of <code>exec_js</code> and <code>broadcast_js</code>. Exciting!
        </p>
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">New example - The Chat <span class="label label-default">2017-05-04</span></div>
      <div class="panel-body">
        <p>
          What is the websocket-based application without a chat? Now, you can learn how to create the simplest one with Drab, based on <a href="#chat_example">this example</a>.
        </p>
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">Drab v0.3.2 - tests, tests and tests <span class="label label-default">2017-04-14</span></div>
      <div class="panel-body">
        <p>
          The <a href="https://github.com/grych/drab/releases/tag/v0.3.2">new release</a> introductes automated integration tests, finally. In addition, Drab package on github contains its own Phoenix Server, makes it easier to play with it.
        </p>
      </div>
    </div>

 <h6>See all <a href="https://github.com/grych/drab/releases">Release Notes</a> to learn about the previous releases</h6>

  </div>
</div>
<hr>



<div class="row">
  <a name="simple">
    <h4 class="anchored">Simple Input and Button Example</h4>
  </a>
  <div class="col-md-8">
    <p>
      Here is the simplest example  - text input and the buttons. Clicking the buttons change the string case. Awesome!
    </p>
    <p>
      On the client side there is a basic HTML with the input and the button:
      <pre><code class="html">&lt;form&gt;
  &lt;input name=&quot;text_to_uppercase&quot; value=&quot;&lt;%= @text %&gt;&quot;&gt;
  &lt;button drab-event=&quot;click&quot; drab-handler=&quot;uppercase&quot;&gt;Upcase&lt;/button&gt;
  &lt;button drab-event=&quot;click&quot; drab-handler=&quot;lowercase&quot;&gt;Downcase&lt;/button&gt;
&lt;/form&gt;
</code></pre>
    </p>
    <p>
      What is a difference between standard html behaviour and Drab? Drab does not GETs or POSTs the form, it calls the event handler function via websockets instead, and updates the DOM nodes directly on the page. As you can see, clicking the button does not reload the page!
    </p>
    <p>
      The idea is to reuse the existing Phoenix templates, but make them living. The pair of <code>drab-event</code> and <code>drab-handler</code> attributes in the <code>&lt;button&gt;</code> determines which <strong>event</strong> should be handled by which <strong>handler</strong>. This handler is a function in the <strong>commander</strong> module, analogically to action in the controller. And a commander is like a controller for living Drab pages.
    </p>
    <p>
      In this example, <code>click</code> event <b>in the browser</b> remotely runs <code>DrabPoc.LiveCommander.uppercase/2</code> <b>on the server.</b>
      <pre><code class="elixir">defmodule DrabPoc.LiveCommander do
  use Drab.Commander

  def uppercase(socket, sender) do
    text = sender.params[&quot;text_to_uppercase&quot;]
    poke socket, text: String.upcase(text)
  end
end</code></pre>
    </p>
    <p>
      Every <em>handler</em> function takes two parameters: first is a <code>%Phoenix.Socket{}</code>, and the second is a map with information about sender DOM object, as well as parameters from the surrounding form. <code>sender.params</code> contains values of all the <em>input</em> elements inside the form, where the keys are element's <code>name</code> or <code>id</code>.
    </p>
    <p>
      After processing the inputs, we need to present it to back in the browser. This is where we use <code>poke/2</code> function - <b>it pushes the assign</b> (in this case: <code>&lt;%= @text %&gt;</code>) <b>back to the browser</b>. Input value is updated, without reloading the whole page.
    </p>
    <p>
      Notice that you can have many event launchers (buttons, inputs, links) in the form, each one will call the different event handler. The second function handler is very similar, just makes the text lowercase.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      This is a live demo. Click the button to launch <code>DrabPoc.LiveCommander.uppercase/2</code> on the server.
      <br><br>
      <form>
        <input class="form-control" name="text_to_uppercase" value="<%= @text %>"><br>
        <button class="btn btn-primary" id="uppercase_button" drab-event="click" drab-handler="uppercase">Upcase</button>
        <button class="btn btn-primary" id="lowercase_button" drab-event="click" drab-handler="lowercase">Downcase</button>
      </form>
    </p>
    </p>
  </div>
</div>
<hr>


<div class="row">
  <a name="poke">
    <h4 class="anchored">POKE and PEEK strike back</h4>
  </a>
  <div class="col-md-8">
    <p>
      <code>poke/2</code> is the most important function in Drab, so we should get a little bit deeper. Let's assume you have your <code>index.html.eex</code> already prepared, displaying some user list. There are two assigns there, <code>@title</code> and <code>@users</code>:
<pre><code class="html">&lt;strong&gt;&lt;%= @title %&gt;:&lt;/strong&gt;&lt;br&gt;
&lt;%= for user &lt;- @users do %&gt;
  Username: &lt;%= user %&gt;&lt;br&gt;
&lt;% end %&gt;
</code></pre>
The code is rendered as usual, in the simple Controller:
<pre><code class="elixir">defmodule DrabPoc.LiveController do
  use DrabPoc.Web, :controller
  use Drab.Controller

  def index(conn, _params) do 
    render conn, "index.html", users: ["Dżesika", "Brajanek", "Zdzichu"], title: "Users List"
  end
end
</code></pre>
    </p>
    <p>
      Nothing special yet, except <code>use Drab.Controller</code>, which tells the controller that is has a corresponding commander. But, the goal of Drab is to update <code>assigns</code> live, without re-rendering the whole page. For this, <code>Drab</code> introduces its own <code>EEx Engine</code>. By default, it uses <code>.drab</code> extension, so you need to rename <code>index.html.eex</code> to <code>index.html.drab</code>.
    </p>
    <p>
    Then, create some button to launch the Drab event in the commander, on the server-side:
<pre><code class="html"><%=~s(<button drab-click="replace_list">Replace List</button>)%></code></pre>
    Did you notice <code>drab-click</code> attribute? This is a shorthand for <code>drab-event</code> and <code>drab-handler</code> combination. There is a number of such shorthands for most popular events, see documentation for more.
    </p>
    <p>The event handler function simply replaces the users list with the new one:
<pre><code class="elixir"><%=~s/defmodule DrabPoc.LiveCommander do
  use Drab.Commander

  def replace_list(socket, _sender) do
    Drab.Live.poke socket, users: ["Mścisław", "Bożydar", "Mściwój", "Bogumił", "Mirmił"]
  end
end/%></code></pre>
    What is going on here? We've just modified the assign <code>@users</code> with the new value. <code>Drab.Live.poke</code> pushes the new value and re-evaluate the corresponding part of the template. Notice that you don't have to <code>poke</code> all assigns, <strong>Drab</strong> remembers what was there previously, and replaces only the assigns you've poked (in this case, <code>@users</code>). 
    </p>
    <p>
      The second button runs <code>replace_title</code> event handler, which changes the value of the <code>@title</code> assign:
<pre><code class="elixir"><%=~s/def replace_title(socket, _sender) do
  Drab.Live.poke socket, title: "New, better Title"
end/%></code></pre>
    Of course you can change the values of many assigns in one <code>poke</code>, Drab will find and update the correspoding parts of the page.
    </p>
    <p>
      Last, but not least, is a possibility to get the current value of assigns. For this, we have a function called <code>peek/2</code>. It returns the current value of the assign. In the example, the third button adds something to the existing list of users:
<pre><code class="elixir"><%=~s/def add_to_list(socket, _sender) do
  users = Drab.Live.peek(socket, :users)
  Drab.Live.poke socket, users: users ++ ["Hegemon"]
end/%></code></pre>
    </p>
    <p>
      Notice that the assign is not updated, when it is a value of some <code>input</code> element, and the user changes it. This is why we couldn't use <code>peek/2</code> in the previous example.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <strong><%= @title %>:</strong><br>
      <%= for user <- @users do %>
        Username: <%= user %> <br>
      <% end %>
    </p>
    <p>
      <br><br>
      <button class="btn btn-primary" drab-event="click" drab-handler="replace_list">Replace List</button>
      <br><br>
      <button class="btn btn-primary" drab-event="click" drab-handler="replace_title">Replace Title</button>
      <br><br>
      <button class="btn btn-primary" drab-event="click" drab-handler="add_to_list">Add to Existing List</button>
    </p>
  </div>

</div>
<hr>



<div class="row">
  <a name="long_running">
    <h4 class="anchored">Long Running Process with Live Attributes and Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      Let's move on to show how to live update DOM node attributes and properties. At the same time, the example is going to demonstrate what Drab is good in: controlling user interface from long-running server process. <br>
      Assume we have a process which is doing some stuff on the server side, and we want to report back to the user after each completed step. We will use the progress bar controlled from the server.
      <pre><code class="html">&lt;div class=&quot;progress&quot;&gt;
  &lt;div class=&quot;progress-bar &lt;%= @progress_bar_class %&gt;&quot; @style.width=&lt;%= &quot;#{@bar_width}%&quot; %&gt;&gt;
    &lt;%= &quot;#{@bar_width}%&quot; %&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;button class=&quot;btn btn-primary&quot; drab-click=&quot;perform_long_process&quot;&gt;&lt;%= @long_process_button_text %&gt;&lt;/button&gt;</code></pre>
      Notice that this time we used assigns in the DOM node attributes: <code>class</code> and <code>@style.width</code>. What will happen when we <code>poke</code> this assigns from the controller? In the first case, <code>class</code> <strong>attribute</strong> is updated as expected. In the second case, Drab sets <code>style.width</code> <strong>property</strong> of the corresponding node to whatever is <strong>evaluated of the given Elixir expression</strong>.
    </p>
    <p>
      We are going to live update the assigns of the template above from <code>perform_long_process/2</code> function in the commander:
      <pre><code class="elixir">def perform_long_process(socket, _sender) do
  poke socket, progress_bar_class: &quot;progress-bar-danger&quot;, long_process_button_text: &quot;Processing...&quot;

  steps = :rand.uniform(100)
  for i &lt;- 1..steps do
    Process.sleep(:rand.uniform(500)) #simulate real work
    poke socket, bar_width: Float.round(i * 100 / steps, 2)
  end

  poke socket, progress_bar_class: &quot;progress-bar-success&quot;, long_process_button_text: &quot;Click me to restart&quot;
end</code></pre>
      This function simulates some process, which updates the User Interface after each step done. For more fun, we randomly choose the number of steps and the step "processing time". 
    </p>
    <p>
      Before running loop of steps, we update the button text (to show the user that the work is in progress), and the progress bar <code>class</code> attribute. In the template, it was initially set to <code>class=&quot;progress-bar &lt;%= @progress_bar_class %&gt;&quot;</code>. After <em>poking</em> the <code>@progress_bar_class</code> assign, Drab updates the <code>class</code> attribute of the node, preserving the given pattern: it will become <code>class=&quot;progress-bar progress-bar-danger&quot;</code>.
    </p>
    <p>
      Even more interesting happens when <em>poking</em> the <code>@bar_width</code> assign. Using the <strong><code>@property=&lt;%= expression %&gt;</code> syntax</strong>, we can bound any node property with the Elixir expression! In this case, <code>@style.width=&lt;%= &quot;#{@bar_width}%&quot; %&gt;</code> connects <code>style.width</code> of the DOM object with <code>&quot;#{@bar_width}%&quot;</code> expression. Elixir expression is evaluated every time you <code>poke</code> a new value of the assign(s), and the value of the evaluated expression updates given node property.
    </p>
    <p>
      Unlike attributes, properties may be bound to any JSON encodable value: a list, a map, etc. And because of this, properties syntax does have some limitations. The only valid sytax is <code>@property=&lt;%= expression %&gt;</code>, no quotes or apostrophes. You can only bind one expression to one property; you may not use string patterns, like you could with attributes.
    </p>
    <p>
      One more thing: you probably noticed that when the task is "processing", you can click another button in the page. This is because <strong>Drab requests are asynchronous on the server side</strong>. And this is a reason why buttons are disabled by default while processing - it is blocking the user from running the same action for few times. You may override this behaviour in `config.exs` with:
      <pre><code class="elixir"><%=~s/config :drab, disable_controls_while_processing: false/%></code></pre>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Click a button to simulate long-running process on the server.
      <div class="progress">
        <div class="progress-bar <%= @progress_bar_class %>" role="progressbar" @style.width=<%= "#{@bar_width}%" %>>
          <%= "#{@bar_width}%" %>
        </div>
      </div>
      <button class="btn btn-primary" drab-click="perform_long_process"><%= @long_process_button_text %></button>
    </p>
  </div>
</div>
<hr>




<div class="row">
  <a name="async_task">
    <h4 class="anchored">Tens of Tasks Running in Parallel on the Server and Communicating Back to the Browser</h4>
  </a>
  <div class="col-md-8">
    <p>
      In the next example we will emulate long running server Process composed of a number of Tasks, which can be run asynchronously. We want to run it in parallel, change their status when they finish the job and - when all of them are done - change the status of the whole process.
    </p>
    <p>
     HTML side contains button and few spans to display the status of the process and tasks:     
     <pre><code class="html"><%=~s(Async task status: 
<span id="async_task_status" class="label label-primary">
  ready
</span>
<span class="task label label-danger" task-id="1">Task 1</span>
  ...
<span class="task label label-danger" task-id="54">Task 54</span>
<button drab-click="run_async_tasks">Start async task</button>)%></code></pre>
    </p>
    <p>
      All the processing is on the server side. Clicking the button runs <code>run_async_tasks/2</code> function:
      <pre><code class="elixir">def run_async_tasks(socket, _sender) do
  poke socket, async_task_label: &quot;danger&quot;, async_task_status: &quot;running&quot;
  set_attr(socket, &quot;.task[task-id]&quot;, class: &quot;task label label-danger&quot;)

  tasks = Enum.map(1..54, fn(i) -&gt; Task.async(fn -&gt; 
      Process.sleep(:rand.uniform(4000)) # simulate real work
      set_prop(socket, &quot;.task[task-id='#{i}']&quot;, className: &quot;task label label-success&quot;)
    end)
  end)

  begin_at = :os.system_time(:millisecond)
  Enum.each(tasks, fn(task) -&gt; Task.await(task) end)
  end_at = :os.system_time(:millisecond)
  
  poke socket, async_task_label: &quot;success&quot;, async_task_status: 
    &quot;finished in #{(end_at - begin_at)/1000} seconds&quot;
end</code></pre>
      The code above runs asynchronously 54 Tasks, which just wait some time (up to 4 seconds) and then communicate to the user by changing the boostrap class from <code>label-danger</code> to <code>label-success</code>. After launching the background tasks, it waits (<code>Task.await/1</code>) for all of the tasks to finish and then informs the user by changing the overall status to "finished".
    </p>
    <p>
      There are two new functions here: <code>set_attr/3</code> and <code>set_prop/3</code>. Both are members of <code>Drab.Element</code> module, which is the one for query and manipulate HTML element attributes and properties. They take the CSS selector as an argument, and modifies all the elements found by this selector.
    </p>
    <p>
      You may think: <b>what is the difference between this approach and running 54 AJAX requests which launches action on the controller side?</b> Well, except of <code>Drab</code> natural beauty, you can't do it with AJAX. You browser <a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">limits the number of simultaneus connections</a>.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Click the button below to simulate server-side long running process with asynchronous tasks.
      <h4>Async task status: <span class="label label-<%= @async_task_label %>"><%= @async_task_status %></span></h4>
      <div class="row">
        <%= for i <- 1..54 do %>
          <div class="col-md-2 col-xs-4 centered">
            <span class="task label label-danger" task-id="<%= i %>">Task #<%= i |> Integer.to_string |> String.rjust(2, ?0) %></span>
          </div>
        <% end %>
      </div>
      <br>
      <button class="btn btn-primary" drab-click="run_async_tasks">Start async task</button>
    </p>
  </div>
</div>
<hr>




<div class="row">
  <a name="tail_dash_f">
    <h4 class="anchored">Server-Side Events: Display the Growing File (tail -F)</h4>
  </a>
  <div class="col-md-8">
    <p>
      Another great example of Drab usage is to display the files, which are changing over the time, like log files. In the normal, Ajax world, you need to send a request periodically to refresh the view, and you never know, if the file changed or not. What a waste of resouces!
    </p>
    <p>
      Let's create a space for the access log, and fill it up with some initial message:
      <pre><code class="html">&lt;pre&gt;&lt;code class=&quot;accesslog&quot;&gt;&lt;%= @access_log %&gt;&lt;/code&gt;&lt;/pre&gt;</code></pre>
    </p>
    <p>
      With Drab, you can utilize the events on the Server Side: in this case to use <code>fsevent</code> to trace the changes in the file. So you upgrade the UI view only in case when something really happened.
    </p>
    <p>
      To enable the Server-Side event watcher, we are going to introduce the Drab Callbacks. Callbacks are events launched automatically, when page is loaded, when browser reconnects or disconnects from the Server. To enable it you need to specify them in the Commander:
<pre><code class="elixir"><%=~s/use Drab.Commander
  onconnect :connected
  ...
end/%></code></pre>
      <code>onconnect</code> launches every time client connects to the server, so after first load, network crashes, server crashes etc. There is also <code>onload</code> callback, which runs only once and ignores disconnects.
    </p>
    <p>
      In the callback implementation we subscribe to <code>Sentix</code> file watcher (it is a wrapper around <code>fswatch</code> utility): 
<pre><code class="elixir"><%=~s/def connected(socket) do
  # Sentix is already started within application supervisor
  Sentix.subscribe(:access_log)

  file_change_loop(socket, Application.get_env(:drab_poc, :watch_file))
end/%></code></pre>
      Watcher sends a message each time the file change. In this case we are going to update the <code>@access_log</code> assign to present the last few lines of the file. 
<pre><code class="elixir"><%=~s/defp file_change_loop(socket, file_path) do
  receive do
    {_pid, {:fswatch, :file_event}, {^file_path, _opts}} ->
      socket |> poke(access_log: last_n_lines(file_path, 8))
  end
  file_change_loop(socket, file_path)
end/%></code></pre>
    </p>
    <p>
      There is also the <code>disconnect</code> callback, which runs every time browser disconnects from the server - close the browser, navigate away from the page, network issue, etc. Obviously there is no way to show it on the Demo page, as it operates when the page is not visible anymore.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      This is a realtime view of few last lines of the access.log of this page
      <pre><code id="log_file" class="accesslog"><%= @access_log %></code></pre>
    </p>
  </div>
</div>
<hr>


<div class="row">
  <a name="broadcast">
    <h4 class="anchored">Is Drab Quick Enough? Plus Broadcast</h4>
  </a>
  <div class="col-md-8">
    <p>
      You may concern about Drab performance - is it quick enough to handle events in the realtime? The best to find it out is to check with, lets say, the <code>keyup</code> event.
      <pre><code class="html">&lt;input drab-keyup=&quot;changed_input&quot; class=&quot;form-control&quot; data-update=&quot;#display_placeholder&quot;&gt;
&lt;div id=&quot;display_placeholder&quot;&gt;&lt;/div&gt;</code></pre>
      <pre><code class="elixir">def changed_input(socket, sender) do
  broadcast_prop socket, sender[&quot;dataset&quot;][&quot;update&quot;], innerText: String.upcase(sender[&quot;value&quot;])
end</code></pre>
    </p>
    <p>
      Did you notice the new <code>broadcast_prop/3</code> function? This one works exactly like <code>set_prop/3</code>, but it <strong>broadcasts to all the browsers</strong> on which the current page is opened. Open another browser window or even another browser and observe what is going on when you type in. <br>
      By default, broadcasts are sent to the displayers of the current page, but you may change this behaviour by setting up <code>broadcasting</code> option in the Commander. For example, setting <code>broadcasting :same_controller</code> will send this <code>broadcast_prop</code> to all browsers which have opened the pages generated in the current controller.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Demonstration of <code>keyup</code> event:
      <input drab-keyup="changed_input" class="form-control" data-update="#display_placeholder">
      <div id="display_placeholder"></div>
    </p>
  </div>

  <div class="col-md-8">
    <p>
      In many situation you don't need to react on every single key press, and you want to launch the event when user stop typing. The good example is autocomplete - you don't want to search the database after each keypress. This is the are where <code>debounce()</code> option becomes handy:
      <pre><code class="html">&lt;input drab-keyup=&quot;changed_input&quot; 
       drab-options=&quot;debounce(500)&quot; 
       data-update=&quot;#display_placeholder2&quot;&gt;
&lt;div id=&quot;display_placeholder&quot;&gt;Some text here&lt;/div&gt;</code></pre>
      <pre><code class="html"><%= 

~s[<input drab-keyup="changed_input"  drab-options="debounce(500)" data-update="#display_placeholder2">
<div id="display_placeholder">Some text here</div>]

%>
      </code></pre>
      The code above is exactly the same as previous, except of <code>debounce(500)</code> option. The same event handler (<code>changed_input/2</code>) is launched, but not after every key up, but when you actually stop typing for 500 miliseconds. 
    </p>
  </div>
  <div class="col-md-4 left-bordered">
    <p>
      The same event with <code>debounce(500)</code>:
      <input drab-keyup="changed_input" drab-options="debounce(500)" data-update="#display_placeholder2" class="form-control">
      <div id="display_placeholder2"></div>
    </p>
  </div>

</div>
<hr>






<div class="row">
  <a name="properties">
    <h4 class="anchored">Special Form for Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      <pre><code class="html"></code></pre>
    </p>
    <p>
      <pre><code class="html"></code></pre>
      <pre><code class="elixir"></code></pre>
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Click the button to sleep <br><br>
      <%= for i <- 1..3 do %>
        <button drab-click="clicked_sleep_button" class='btn <%= @sleep_button_classes[i] %>' data-sleep="<%= i %>">Sleep <%= i %> second(s)</button><br><br>
      <% end %>
    </p>
  </div>
</div>
<hr>






<div class="row">
  <a name="properties">
    <h4 class="anchored">Special Form for Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      <pre><code class="html"></code></pre>
    </p>
    <p>
      <pre><code class="html"></code></pre>
      <pre><code class="elixir"></code></pre>
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
    </p>
  </div>
</div>
<hr>









<div class="row">
  <a name="attributes">
    <h4 class="anchored">Living Attributes</h4>
  </a>
  <div class="col-md-8">
    <p>
      With Drab.Live, you may also remote control tag attributes, like <code>class</code> or <code>style</code>. Imagine you generated the page with <code>@label</code> assign.
<pre><code class="elixir"><%=~s/def index(conn, _params) do
  render conn, "index.html", label: "default"
end/%></code></pre>
      with such template:
      <pre><code class="html">&lt;span class='label label-&lt;%= @label %&gt;'&gt;Label: &lt;%= @label %&gt;&lt;/span&gt;
&lt;input drab-change="changed_label" value="&lt;%= @label%&gt;"&gt;</code></pre>
    </p>
    <p>
      With <code>Drab.Live</code>, you don't have to reload the whole page to update the <code>class</code> of the <code>&lt;span&gt;</code>. You may just poke it from the <code>Commander</code>:
<pre><code class="elixir"><%=~s/def changed_label(socket, sender) do
  poke socket, label: sender["value"]
end/%></code></pre>
    </p>
    <p>
      <strong>Limitation Warning:</strong> you may only update named attibutes in that way. This means that the following is prohibited:
      <pre><code class="html">&lt;tag &lt;%= &quot;attribute=&#039;value&#039;&quot;%&gt; &gt;</code></pre>
      and will not work.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <h2><span class="label label-<%= @label %>">Label: <%= @label %></span></h2>
    </p>
    <p>
      Try to change it to <em>success</em>, <em>primary</em>, <em>info</em>
      <input drab-change="changed_label" class="form-control" placeholder="primary, success, info, danger, etc" value="<%= @label%>">
    </p>
  </div>

</div>
<hr>

<div class="row">
  <a name="scripts">
    <h4 class="anchored">Living Scripts</h4>
  </a>
  <div class="col-md-8">
    <p>
      Drab can also serve the expression, which are inside the <code>&lt;script&gt;</code> tag. In the following example we rendered the template with <code>@button_height</code> set to <code>30</code> (integer): 
<pre><code class="elixir"><%=~s/render conn, "index.html", button_height: 30/%></code></pre>
      with such template:
      <pre><code class="html">&lt;button drab-click=&quot;enlage_your_button_now&quot; class=&quot;btn btn-success&quot;&gt;Enlage You Button Now&lt;/button&gt;&lt;br&gt;&lt;br&gt;
&lt;button id=&quot;growing_button&quot; class=&quot;btn btn-info&quot;&gt;My Growing Button&lt;/button&gt;
&lt;script&gt;
  document.querySelector(&quot;#growing_button&quot;).style.height = &quot;&lt;%= @button_height %&gt;px&quot;
&lt;/script&gt;</code></pre>
    </p>
    <p>
    Your browser will immediate run the script, setting <code>.style</code> property to the expected value. But what is going to happen when you <code>poke</code> the <code>@button_height</code> assign with a new value? In this case, Drab will re-evaluate the whole script, making the property <code>.style.heigth</code> bound to the <code>@button_heigth</code> assign.
<pre><code class="elixir"><%=~s/def enlage_your_button_now(socket, _sender) do
  poke socket, button_height: peek(socket, :button_height) + 2
end/%></code></pre>
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <button drab-click="enlage_your_button_now" class="btn btn-success">Enlage You Button Now</button><br><br>
      <button id="growing_button" class="btn btn-info">My Growing Button</button>
      <script>
        document.querySelector("#growing_button").style.height = "<%= @button_height %>px"
      </script>
    </p>
  </div>
</div>
<hr>

<div class="row">
  <a name="properties">
    <h4 class="anchored">Special Form for Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      For dealing with properties, Drab introduces the Special Syntax: <code>&lt;tag @property=&lt;%= expression %&gt;&gt;</code>. Let's re-use the previous example, but bind the <code>button_height</code> assign with <code>.style.height</code> property of the <code>&lt;button&gt;</code>, using the Special Form:
      <pre><code class="html">&lt;button drab-click=&quot;enlage_your_button_now&quot; class=&quot;btn btn-success&quot;&gt;Enlage You Button Now&lt;/button&gt;&lt;br&gt;&lt;br&gt;
&lt;button @style.height=&lt;%= &quot;#{@button_height}px&quot; %&gt; class=&quot;btn btn-info&quot;&gt;My Growing Button&lt;/button&gt;</code></pre>
    </p>
    <p>
      When we <code>poke/2</code> the updated assign, Drab will update the corresponding Node with the new value of <code>.style.height</code> property. Notice that, as in the example, you may use the full path to the property. Also, despite that attributes are not case-sensitive, <b>Drab handles the case</b>, allowing you to use <code>@style.backgroundColor</code> et consortes.
    </p>
    <p>
      The expression binded with the property <b>must be encodable to JS</b>, so, for example, tuples are not allowed here. But, unlike the attributes, you are not limited to Strings. You may bind any JS encodable value. With this comes limitation: you can only bind one expression to one property; you may not use string patterns, like you did with attributes. In the other words, <code>@style.height=&quot;&lt;%= @height %&gt;px&quot;</code> is prohibited. You have to use <code>@style.height=&lt;%= &quot;#{height}px&quot; %&gt;</code> instead.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <button drab-click="enlage_your_button_now" class="btn btn-success">Enlage You Button Now</button><br><br>
      <button @style.height=<%= "#{@button_height}px" %> class="btn btn-info">My Growing Button</button>
    </p>
  </div>
</div>


