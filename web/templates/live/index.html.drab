<h3 class="centered">Drab - Access the User Interface in browser from the Server Side</h3>
<h4 class="centered">
  Living EEx Pages in Phoenix
</h4>

<div class="row">

  <div class="col-md-8">
    <p>
      <img src="<%= static_path(@conn, "/images/drab-logo-200.png")%>" class="drab-logo" alt="pipe-shaped slingshot" title="pipe-shaped slingshot">
      In the <i>"good old times"</i> the event handling was easy. The only thing you had to do was to create the event handler (remember <code>TForm1.Button1Click(Sender: TObject)</code>?) and you could do everything inside this handler: accessing data from models, manipulating user interface, sending raw Ethernet packets to the coffee machine...
    </p>
    <p>
      Nowadays, when the most of the applications are web based, it is not so easy anymore. You need either to create a form and submit the data via POST or GET or use AJAX to send or retrieve data. Whole interface manipulation is on the client side. In practice, you need to write two applications: on the client and the server side.  
    </p>
    <p>
      Additionally, because <code>http</code> is stateless and a one-way protocol, it is not easy to communicate back from the server to the browser. Like, for example, during execution of the long running process, when there is a need to update status (eg. progress bar), or to ask the operator about something (like "would you like to continue?"). Of course there are workarounds for this, like polling the server every few seconds to have a status, or even auto-refreshing the page, but those are just a dirty workarounds. The solution would be to allow an access to the interface directly from the server side. And here comes <code>Drab</code>.
    </p>
    <p>
      <code>Drab</code> is a concept of <b>providing an access to User Interface (DOM objects) on the server side</b>, just like in the 
      good-old Delphi times. The examples below should give you an overview of how does it work. For more detailed instructions, please refer to the <a href="https://hexdocs.pm/drab">documentation</a>.
    </p>
    <p>
      Drab is written using <strong>Phoenix on Elixir</strong>, so all the code in examples is HTML and Elixir. <b>This page is a living demo - all examples are actually working on the Drab server</b>.
      You can find a source code of this page <a href="https://github.com/grych/drab-poc">on Github</a>, and the <a href="https://github.com/grych/drab">source code of the Drab himself - here</a>.
    </p>
    <p><small>&copy; <a href="mailto:grych@tg.pl">Tomek "Grych" Gryszkiewicz</a> 2016 - 2017</small></p>
    <iframe src="https://ghbtns.com/github-btn.html?user=grych&repo=drab&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe><br>
    <iframe src="https://ghbtns.com/github-btn.html?user=grych&repo=drab&type=watch&count=true&v=2" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>
  </div>



  <div class="col-md-4 left-bordered">
    <div class="panel panel-default">
      <div class="panel-heading">v0.4.0 improves reliability <span class="label label-default">2017-05-16</span></div>
      <div class="panel-body">
        <p>
          <a href="https://github.com/grych/drab/releases/tag/v0.4.0">This version</a> introduces redesigned API for the most essential part of Drab API: <code>Drab.Core</code>. <code>execjs</code> and <code>broadcastjs</code> has been depreciated in favor of <code>exec_js</code> and <code>broadcast_js</code>. Exciting!
        </p>
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">New example - The Chat <span class="label label-default">2017-05-04</span></div>
      <div class="panel-body">
        <p>
          What is the websocket-based application without a chat? Now, you can learn how to create the simplest one with Drab, based on <a href="#chat_example">this example</a>.
        </p>
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">Drab v0.3.2 - tests, tests and tests <span class="label label-default">2017-04-14</span></div>
      <div class="panel-body">
        <p>
          The <a href="https://github.com/grych/drab/releases/tag/v0.3.2">new release</a> introductes automated integration tests, finally. In addition, Drab package on github contains its own Phoenix Server, makes it easier to play with it.
        </p>
      </div>
    </div>

 <h6>See all <a href="https://github.com/grych/drab/releases">Release Notes</a> to learn about the previous releases</h6>

  </div>
</div>
<hr>



<div class="row">
  <a name="simple">
    <h4 class="anchored">Simple Input and Button Example</h4>
  </a>
  <div class="col-md-8">
    <p>
      Here is the simplest example  - text input and the buttons. Clicking the buttons change the string case. Awesome!
    </p>
    <p>
      On the client side there is a basic HTML with the input and the button:
      <pre><code class="html">&lt;form&gt;
  &lt;input name=&quot;text_to_uppercase&quot; value=&quot;&lt;%= @text %&gt;&quot;&gt;
  &lt;button drab-event=&quot;click&quot; drab-handler=&quot;uppercase&quot;&gt;Upcase&lt;/button&gt;
  &lt;button drab-event=&quot;click&quot; drab-handler=&quot;lowercase&quot;&gt;Downcase&lt;/button&gt;
&lt;/form&gt;
</code></pre>
    </p>
    <p>
      What is a difference between standard html behaviour and Drab? Drab does not GETs or POSTs the form, it calls the event handler function via websockets instead, and updates the DOM nodes directly on the page. As you can see, clicking the button does not reload the page!
    </p>
    <p>
      The idea is to reuse the existing Phoenix templates, but make them living. The pair of <code>drab-event</code> and <code>drab-handler</code> attributes in the <code>&lt;button&gt;</code> determines which <strong>event</strong> should be handled by which <strong>handler</strong>. This handler is a function in the <strong>commander</strong> module, analogically to action in the controller. And a commander is like a controller for living Drab pages.
    </p>
    <p>
      In this example, <code>click</code> event <b>in the browser</b> remotely runs <code>DrabPoc.LiveCommander.uppercase/2</code> <b>on the server.</b>
      <pre><code class="elixir">defmodule DrabPoc.LiveCommander do
  use Drab.Commander

  def uppercase(socket, sender) do
    text = sender.params[&quot;text_to_uppercase&quot;]
    poke socket, text: String.upcase(text)
  end
end</code></pre>
    </p>
    <p>
      Every <em>handler</em> function takes two parameters: first is a <code>%Phoenix.Socket{}</code>, and the second is a map with information about sender DOM object, as well as parameters from the surrounding form. <code>sender.params</code> contains values of all the <em>input</em> elements inside the form, where the keys are element's <code>name</code> or <code>id</code>.
    </p>
    <p>
      After processing the inputs, we need to present it to back in the browser. This is where we use <code>poke/2</code> function - <b>it pushes the assign</b> (in this case: <code>&lt;%= @text %&gt;</code>) <b>back to the browser</b>. Input value is updated, without reloading the whole page.
    </p>
    <p>
      Notice that you can have many event launchers (buttons, inputs, links) in the form, each one will call the different event handler. The second function handler is very similar, just makes the text lowercase.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      This is a live demo. Click the button to launch <code>DrabPoc.LiveCommander.uppercase/2</code> on the server.
      <br><br>
      <form>
        <input class="form-control" name="text_to_uppercase" value="<%= @text %>"><br>
        <button class="btn btn-primary" id="uppercase_button" drab-event="click" drab-handler="uppercase">Upcase</button>
        <button class="btn btn-primary" id="lowercase_button" drab-event="click" drab-handler="lowercase">Downcase</button>
      </form>
    </p>
    </p>
  </div>
</div>
<hr>


<div class="row">
  <a name="poke">
    <h4 class="anchored">POKE and PEEK strike back</h4>
  </a>
  <div class="col-md-8">
    <p>
      <code>poke/2</code> is the most important function in Drab, so we should get a little bit deeper. Let's assume you have your <code>index.html.eex</code> already prepared, displaying some user list. There are two assigns there, <code>@title</code> and <code>@users</code>:
<pre><code class="html">&lt;strong&gt;&lt;%= @title %&gt;:&lt;/strong&gt;&lt;br&gt;
&lt;%= for user &lt;- @users do %&gt;
  Username: &lt;%= user %&gt;&lt;br&gt;
&lt;% end %&gt;
</code></pre>
The code is rendered as usual, in the simple Controller:
<pre><code class="elixir">defmodule DrabPoc.LiveController do
  use DrabPoc.Web, :controller
  use Drab.Controller

  def index(conn, _params) do 
    render conn, "index.html", users: ["Dżesika", "Brajanek", "Zdzichu"], title: "Users List"
  end
end
</code></pre>
    </p>
    <p>
      Nothing special yet, except <code>use Drab.Controller</code>, which tells the controller that is has a corresponding commander. But, the goal of Drab is to update <code>assigns</code> live, without re-rendering the whole page. For this, <code>Drab</code> introduces its own <code>EEx Engine</code>. By default, it uses <code>.drab</code> extension, so you need to rename <code>index.html.eex</code> to <code>index.html.drab</code>.
    </p>
    <p>
    Then, create some button to launch the Drab event in the commander, on the server-side:
<pre><code class="html"><%=~s(<button drab-click="replace_list">Replace List</button>)%></code></pre>
    Did you notice <code>drab-click</code> attribute? This is a shorthand for <code>drab-event</code> and <code>drab-handler</code> combination. There is a number of such shorthands for most popular events, see documentation for more.
    </p>
    <p>The event handler function simply replaces the users list with the new one:
<pre><code class="elixir"><%=~s/defmodule DrabPoc.LiveCommander do
  use Drab.Commander

  def replace_list(socket, _sender) do
    Drab.Live.poke socket, users: ["Mścisław", "Bożydar", "Mściwój", "Bogumił", "Mirmił"]
  end
end/%></code></pre>
    What is going on here? We've just modified the assign <code>@users</code> with the new value. <code>Drab.Live.poke</code> pushes the new value and re-evaluate the corresponding part of the template. Notice that you don't have to <code>poke</code> all assigns, <strong>Drab</strong> remembers what was there previously, and replaces only the assigns you've poked (in this case, <code>@users</code>). 
    </p>
    <p>
      The second button runs <code>replace_title</code> event handler, which changes the value of the <code>@title</code> assign:
<pre><code class="elixir"><%=~s/def replace_title(socket, _sender) do
  Drab.Live.poke socket, title: "New, better Title"
end/%></code></pre>
    Of course you can change the values of many assigns in one <code>poke</code>, Drab will find and update the correspoding parts of the page.
    </p>
    <p>
      Last, but not least, is a possibility to get the current value of assigns. For this, we have a function called <code>peek/2</code>. It returns the current value of the assign. In the example, the third button adds something to the existing list of users:
<pre><code class="elixir"><%=~s/def add_to_list(socket, _sender) do
  users = Drab.Live.peek(socket, :users)
  Drab.Live.poke socket, users: users ++ ["Hegemon"]
end/%></code></pre>
    </p>
    <p>
      Notice that the assign is not updated, when it is a value of some <code>input</code> element, and the user changes it. This is why we couldn't use <code>peek/2</code> in the previous example.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <strong><%= @title %>:</strong><br>
      <%= for user <- @users do %>
        Username: <%= user %> <br>
      <% end %>
    </p>
    <p>
      <br><br>
      <button class="btn btn-primary" drab-event="click" drab-handler="replace_list">Replace List</button>
      <br><br>
      <button class="btn btn-primary" drab-event="click" drab-handler="replace_title">Replace Title</button>
      <br><br>
      <button class="btn btn-primary" drab-event="click" drab-handler="add_to_list">Add to Existing List</button>
    </p>
  </div>

</div>
<hr>



<div class="row">
  <a name="long_running">
    <h4 class="anchored">Long Running Process with Live Attributes and Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      Let's move on to show how to live update DOM node attributes and properties. At the same time, the example is going to demonstrate what Drab is good in: controlling user interface from long-running server process. <br>
      Assume we have a process which is doing some stuff on the server side, and we want to report back to the user after each completed step. We will use the progress bar controlled from the server.
      <pre><code class="html">&lt;div class=&quot;progress&quot;&gt;
  &lt;div class=&quot;progress-bar &lt;%= @progress_bar_class %&gt;&quot; @style.width=&lt;%= &quot;#{@bar_width}%&quot; %&gt;&gt;
    &lt;%= &quot;#{@bar_width}%&quot; %&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;button class=&quot;btn btn-primary&quot; drab-click=&quot;perform_long_process&quot;&gt;&lt;%= @long_process_button_text %&gt;&lt;/button&gt;</code></pre>
      Notice that this time we used assigns in the DOM node attributes: <code>class</code> and <code>@style.width</code>. What will happen when we <code>poke</code> this assigns from the controller? In the first case, <code>class</code> <strong>attribute</strong> is updated as expected. In the second case, Drab sets <code>style.width</code> <strong>property</strong> of the corresponding node to whatever is <strong>evaluated of the given Elixir expression</strong>.
    </p>
    <p>
      We are going to live update the assigns of the template above from <code>perform_long_process/2</code> function in the commander:
      <pre><code class="elixir">def perform_long_process(socket, _sender) do
  poke socket, progress_bar_class: &quot;progress-bar-danger&quot;, long_process_button_text: &quot;Processing...&quot;

  steps = :rand.uniform(100)
  for i &lt;- 1..steps do
    Process.sleep(:rand.uniform(500)) #simulate real work
    poke socket, bar_width: Float.round(i * 100 / steps, 2)
  end

  poke socket, progress_bar_class: &quot;progress-bar-success&quot;, long_process_button_text: &quot;Click me to restart&quot;
end</code></pre>
      This function simulates some process, which updates the User Interface after each step done. For more fun, we randomly choose the number of steps and the step "processing time". 
    </p>
    <p>
      Before running loop of steps, we update the button text (to show the user that the work is in progress), and the progress bar <code>class</code> attribute. In the template, it was initially set to <code>class=&quot;progress-bar &lt;%= @progress_bar_class %&gt;&quot;</code>. After <em>poking</em> the <code>@progress_bar_class</code> assign, Drab updates the <code>class</code> attribute of the node, preserving the given pattern: it will become <code>class=&quot;progress-bar progress-bar-danger&quot;</code>.
    </p>
    <p>
      Even more interesting happens when <em>poking</em> the <code>@bar_width</code> assign. Using the <strong><code>@property=&lt;%= expression %&gt;</code> syntax</strong>, we can bound any node property with the Elixir expression! In this case, <code>@style.width=&lt;%= &quot;#{@bar_width}%&quot; %&gt;</code> connects <code>style.width</code> of the DOM object with <code>&quot;#{@bar_width}%&quot;</code> expression. Elixir expression is evaluated every time you <code>poke</code> a new value of the assign(s), and the value of the evaluated expression updates given node property.
    </p>
    <p>
      Unlike attributes, properties may be bound to any JSON encodable value: a list, a map, etc. And because of this, properties syntax does have some limitations. The only valid sytax is <code>@property=&lt;%= expression %&gt;</code>, no quotes or apostrophes. You can only bind one expression to one property; you may not use string patterns, like you could with attributes.
    </p>
    <p>
      One more thing: you probably noticed that when the task is "processing", you can click another button in the page. This is because <strong>Drab requests are asynchronous on the server side</strong>. And this is a reason why buttons are disabled by default while processing - it is blocking the user from running the same action for few times. You may override this behaviour in `config.exs` with:
      <pre><code class="elixir"><%=~s/config :drab, disable_controls_while_processing: false/%></code></pre>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Click a button to simulate long-running process on the server.
      <div class="progress">
        <div class="progress-bar <%= @progress_bar_class %>" role="progressbar" @style.width=<%= "#{@bar_width}%" %>>
          <%= "#{@bar_width}%" %>
        </div>
      </div>
      <button class="btn btn-primary" drab-click="perform_long_process"><%= @long_process_button_text %></button>
    </p>
  </div>
</div>
<hr>




<div class="row">
  <a name="async_task">
    <h4 class="anchored">Tens of Tasks Running in Parallel on the Server and Communicating Back to the Browser</h4>
  </a>
  <div class="col-md-8">
    <p>
      <pre><code class="html"></code></pre>
    </p>
    <p>
      <pre><code class="html"></code></pre>
      <pre><code class="elixir"></code></pre>
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Click the button below to simulate server-side long running process with asynchronous tasks.
      <h4>Async task status: <span class="label label-<%= @async_task_label %>"><%= @async_task_status %></span></h4>
      <div class="row">
        <%= for i <- 1..54 do %>
          <div class="col-md-2 col-xs-4 centered">
            <span class="task label label-<%= @async_task_classes[i] %>">Task #<%= i |> Integer.to_string |> String.rjust(2, ?0) %></span>
          </div>
        <% end %>
      </div>
      <br>
      <button class="btn btn-primary" drab-click="run_async_tasks">Start async task</button>
    </p>
  </div>
</div>
<hr>







<div class="row">
  <a name="properties">
    <h4 class="anchored">Special Form for Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      <pre><code class="html"></code></pre>
    </p>
    <p>
      <pre><code class="html"></code></pre>
      <pre><code class="elixir"></code></pre>
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Click the button to sleep <br><br>
      <%= for i <- 1..3 do %>
        <button drab-click="clicked_sleep_button" class='btn <%= @sleep_button_classes[i] %>' data-sleep="<%= i %>">Sleep <%= i %> second(s)</button><br><br>
      <% end %>
    </p>
  </div>
</div>
<hr>






<div class="row">
  <a name="properties">
    <h4 class="anchored">Special Form for Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      <pre><code class="html"></code></pre>
    </p>
    <p>
      <pre><code class="html"></code></pre>
      <pre><code class="elixir"></code></pre>
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
    </p>
  </div>
</div>
<hr>









<div class="row">
  <a name="attributes">
    <h4 class="anchored">Living Attributes</h4>
  </a>
  <div class="col-md-8">
    <p>
      With Drab.Live, you may also remote control tag attributes, like <code>class</code> or <code>style</code>. Imagine you generated the page with <code>@label</code> assign.
<pre><code class="elixir"><%=~s/def index(conn, _params) do
  render conn, "index.html", label: "default"
end/%></code></pre>
      with such template:
      <pre><code class="html">&lt;span class='label label-&lt;%= @label %&gt;'&gt;Label: &lt;%= @label %&gt;&lt;/span&gt;
&lt;input drab-change="changed_label" value="&lt;%= @label%&gt;"&gt;</code></pre>
    </p>
    <p>
      With <code>Drab.Live</code>, you don't have to reload the whole page to update the <code>class</code> of the <code>&lt;span&gt;</code>. You may just poke it from the <code>Commander</code>:
<pre><code class="elixir"><%=~s/def changed_label(socket, sender) do
  poke socket, label: sender["value"]
end/%></code></pre>
    </p>
    <p>
      <strong>Limitation Warning:</strong> you may only update named attibutes in that way. This means that the following is prohibited:
      <pre><code class="html">&lt;tag &lt;%= &quot;attribute=&#039;value&#039;&quot;%&gt; &gt;</code></pre>
      and will not work.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <h2><span class="label label-<%= @label %>">Label: <%= @label %></span></h2>
    </p>
    <p>
      Try to change it to <em>success</em>, <em>primary</em>, <em>info</em>
      <input drab-change="changed_label" class="form-control" placeholder="primary, success, info, danger, etc" value="<%= @label%>">
    </p>
  </div>

</div>
<hr>

<div class="row">
  <a name="scripts">
    <h4 class="anchored">Living Scripts</h4>
  </a>
  <div class="col-md-8">
    <p>
      Drab can also serve the expression, which are inside the <code>&lt;script&gt;</code> tag. In the following example we rendered the template with <code>@button_height</code> set to <code>30</code> (integer): 
<pre><code class="elixir"><%=~s/render conn, "index.html", button_height: 30/%></code></pre>
      with such template:
      <pre><code class="html">&lt;button drab-click=&quot;enlage_your_button_now&quot; class=&quot;btn btn-success&quot;&gt;Enlage You Button Now&lt;/button&gt;&lt;br&gt;&lt;br&gt;
&lt;button id=&quot;growing_button&quot; class=&quot;btn btn-info&quot;&gt;My Growing Button&lt;/button&gt;
&lt;script&gt;
  document.querySelector(&quot;#growing_button&quot;).style.height = &quot;&lt;%= @button_height %&gt;px&quot;
&lt;/script&gt;</code></pre>
    </p>
    <p>
    Your browser will immediate run the script, setting <code>.style</code> property to the expected value. But what is going to happen when you <code>poke</code> the <code>@button_height</code> assign with a new value? In this case, Drab will re-evaluate the whole script, making the property <code>.style.heigth</code> bound to the <code>@button_heigth</code> assign.
<pre><code class="elixir"><%=~s/def enlage_your_button_now(socket, _sender) do
  poke socket, button_height: peek(socket, :button_height) + 2
end/%></code></pre>
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <button drab-click="enlage_your_button_now" class="btn btn-success">Enlage You Button Now</button><br><br>
      <button id="growing_button" class="btn btn-info">My Growing Button</button>
      <script>
        document.querySelector("#growing_button").style.height = "<%= @button_height %>px"
      </script>
    </p>
  </div>
</div>
<hr>

<div class="row">
  <a name="properties">
    <h4 class="anchored">Special Form for Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      For dealing with properties, Drab introduces the Special Syntax: <code>&lt;tag @property=&lt;%= expression %&gt;&gt;</code>. Let's re-use the previous example, but bind the <code>button_height</code> assign with <code>.style.height</code> property of the <code>&lt;button&gt;</code>, using the Special Form:
      <pre><code class="html">&lt;button drab-click=&quot;enlage_your_button_now&quot; class=&quot;btn btn-success&quot;&gt;Enlage You Button Now&lt;/button&gt;&lt;br&gt;&lt;br&gt;
&lt;button @style.height=&lt;%= &quot;#{@button_height}px&quot; %&gt; class=&quot;btn btn-info&quot;&gt;My Growing Button&lt;/button&gt;</code></pre>
    </p>
    <p>
      When we <code>poke/2</code> the updated assign, Drab will update the corresponding Node with the new value of <code>.style.height</code> property. Notice that, as in the example, you may use the full path to the property. Also, despite that attributes are not case-sensitive, <b>Drab handles the case</b>, allowing you to use <code>@style.backgroundColor</code> et consortes.
    </p>
    <p>
      The expression binded with the property <b>must be encodable to JS</b>, so, for example, tuples are not allowed here. But, unlike the attributes, you are not limited to Strings. You may bind any JS encodable value. With this comes limitation: you can only bind one expression to one property; you may not use string patterns, like you did with attributes. In the other words, <code>@style.height=&quot;&lt;%= @height %&gt;px&quot;</code> is prohibited. You have to use <code>@style.height=&lt;%= &quot;#{height}px&quot; %&gt;</code> instead.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <button drab-click="enlage_your_button_now" class="btn btn-success">Enlage You Button Now</button><br><br>
      <button @style.height=<%= "#{@button_height}px" %> class="btn btn-info">My Growing Button</button>
    </p>
  </div>
</div>


