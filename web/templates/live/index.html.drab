<h3 class="centered">Drab - Access the User Interface from the Server Side</h3>
<h4 class="centered">
  Living Pages in Phoenix
</h4>

<div class="row">

  <div class="col-md-8">
    <p>
      <img src="<%= static_path(@conn, "/images/drab-logo-200.png")%>" class="drab-logo" alt="pipe-shaped slingshot" title="pipe-shaped slingshot">
      <strong>Drab</strong> is the extension library to <a href="http://www.phoenixframework.org">Phoenix Framework</a> for <b>providing an access to the browser's User Interface (DOM objects) from the server side</b>. The main advantage is to eliminate necessity of writing two applications: one for the client-side, and one for the backend. All the UI control may be now done in the backend, eliminating JS and AJAX.
    </p>
    <p>
      Additionally, because <code>http</code> is a stateless and an one-way protocol, it is not easy to communicate back from the server to the browser. Like, for example, during execution of the long running process, when there is a need to update status (eg. progress bar), or to ask the operator about something (like "would you like to continue?"). Of course there are workarounds for this, like polling the server every few seconds to get a status, or even auto-refreshing the page, but those are just a dirty workarounds. The solution would be to allow an access to the interface directly from the server side. And here comes the <code>Drab</code>.
    </p>
    <p>
      Drab is made with <strong><a href="https://elixir-lang.org">Elixir</a> on <a href="http://www.phoenixframework.org">Phoenix</a></strong>. <b>This page is a living demo - all examples are actually working on the Drab server (v<%= {:ok, v} = :application.get_key(:drab, :vsn); v %>)</b>.
      You can find the source code of Drab <a href="https://github.com/grych/drab">on Github</a>, and the source code of this demo page: <a href="https://github.com/grych/drab-poc">here</a>. For more detailed instructions, please refer to the <a href="https://hexdocs.pm/drab">documentation</a>.
    </p>
    <p>
      Drab does not use any browser plugins, flash players, Java applets, Silverlight, etc. It works in any modern browser capable of running HTML5 + Javascript.
    </p>
    <p>
      <u><strong>Teaser:</strong></u> Imagine having a Phoenix template like:
      <pre><code class="html">&lt;a href=&quot;https://&lt;%= @url%&gt;&quot; class=&quot;btn btn-success&quot; @style.width=&lt;%= @width%&gt;&gt;
  Visit &lt;%= @url %&gt;
&lt;/a&gt;</code></pre>
      With Drab, you may remote control this html element, live:<br>
      <video width="692px" height="418px" controls autoplay loop>
        <source src="<%= static_path(@conn, "/images/drab_example.mp4")%>" type="video/mp4">
        Your browser does not support the video tag.
      </video>

    </p>

    <p><small>&copy; <a href="mailto:grych@tg.pl">Tomek "Grych" Gryszkiewicz</a> 2016 - 2018</small></p>
  </div>



  <div class="col-md-4 left-bordered">

    <div class="panel panel-default">
      <div class="panel-heading">v0.7.5: Tge Great Unification <span class="label label-default">2018-04-11</span></div>
      <div class="panel-body">
        <p>
          <a href="https://github.com/grych/drab/releases/tag/v0.7.5">Shared and Page commanders are finally unified.</a>
          Also, <a href="#living_shared">living assigns gained more magic powers</a>!
        </p>
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">v0.7.2: API Changes and Reusable Components <span class="label label-default">2018-04-01</span></div>
      <div class="panel-body">
        <p>
          Please read the <a href="https://github.com/grych/drab/releases/tag/v0.7.2">Release Notes</a> - API has been changed. Also, introduced the new feature: creating reusable components!
        </p>
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">v0.7.0: Drab core rearranged <span class="label label-default">2018-01-22</span></div>
      <div class="panel-body">
        <p>
          <a href="https://github.com/grych/drab/releases/tag/v0.7.0">v0.7.0</a> looks small, but it brings important
          changes in the core.
        </p>
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">v0.6.0: New, better living assigns <span class="label label-default">2017-10-31</span></div>
      <div class="panel-body">
        <p>
          <a href="https://github.com/grych/drab/releases/tag/v0.6.0">This version</a> introduces a completely rewritten <code>Drab.Live</code> module: it is not putting its <code>&lt;span&gt;</code> everywhere into your template. Also introduces <em>Shared Commanders</em>.
        </p>
      </div>
    </div>

    <div class="panel panel-default" style="background-color: #FFE3DA;">
      <div class="panel-heading">v0.5.0 - living assigns <span class="label label-default">2017-07-17</span></div>
      <div class="panel-body">
        <p>
          <strong>WARNING! Drab API has been completely changed in 0.5.0!</strong> <code>Drab.Query</code> (the jQuery based module) is no longer the default one. If you still want to use it, you must declare it in the commander with <code>use Drab.Commander, modules: [Drab.Query, Drab.Modal]</code>. Drab.Query based tutorial is still available <a href="/drab/query">here</a>.
        </p>
      </div>
    </div>


 <h6>See all <a href="https://github.com/grych/drab/releases">Release Notes</a> to learn about the previous releases</h6>
    <iframe src="https://ghbtns.com/github-btn.html?user=grych&repo=drab&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe><br>
    <iframe src="https://ghbtns.com/github-btn.html?user=grych&repo=drab&type=watch&count=true&v=2" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>

  </div>
</div>
<hr>



<div class="row">
  <a name="simple">
    <h4 class="anchored">Introduction</h4>
  </a>
  <div class="col-md-8">
    <p>
      Here is the simplest example  - the text input and the buttons. Clicking the buttons change the string case. Awesome!
    </p>
    <p>
      On the client side there is basic HTML with the input and the button:
      <pre><code class="html">&lt;form&gt;
  &lt;input name=&quot;text_to_uppercase&quot; value=&quot;&lt;%= @text %&gt;&quot;&gt;
  &lt;button drab=&quot;click:uppercase&quot;&gt;Upcase&lt;/button&gt;
  &lt;button drab=&quot;click:downcase&quot;&gt;Downcase&lt;/button&gt;
&lt;/form&gt;
</code></pre>
    </p>
    <p>
      What is a difference between the standard behaviour and Drab? Drab does not GET or POST the form, it calls the event handler function via websockets instead, and updates the DOM nodes directly on the page. As you can see, clicking the button does not reload the page.
    </p>
    <p>
      The idea is to reuse the existing Phoenix templates, but make them living. <code>drab="event:handler"</code> attribute defines on which Phoenix function (handler) is going to be run in case of the given event. This handler is a function in the <strong>commander</strong> module, analogically to action in the controller. A commander is like a controller for living Drab pages.
    </p>
    <p>
      In this example, <code>click</code> event <b>in the browser</b> remotely runs <code>DrabPoc.LiveCommander.uppercase/2</code> <b>on the server.</b>
      <pre><code class="elixir">defmodule DrabPoc.LiveCommander do
  use Drab.Commander

  defhandler uppercase(socket, sender) do
    text = sender.params[&quot;text_to_uppercase&quot;]
    poke socket, text: String.upcase(text)
  end
end</code></pre>
    </p>
    <p>
      The code above creates `uppercase/2` function and mark it as an <em>event handler</em>. Such function takes two parameters: first is a <code>%Phoenix.Socket{}</code>, and the second is a map with information about sender DOM object, as well as parameters from the surrounding form. <code>sender.params</code> contains values of all the <em>input</em> elements inside the form, where the keys are element's <code>name</code> or <code>id</code>.
    </p>
    <p>
      After processing the inputs, we need to present it to back in the browser. This is where we use <code>poke/2</code> function - <b>it pushes the assign</b> (in this case: <code>&lt;%= @text %&gt;</code>) <b>back to the browser</b>. Input value is updated, without reloading the page.
    </p>
    <p>
      Notice that you can have many event launchers (buttons, inputs, links) in the form, each one calling the different event handler. The second function handler is very similar, just makes the text lowercase.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      This is a live demo. Click the button to launch <code>DrabPoc.LiveCommander.uppercase/2</code> on the server.
      <br><br>
      <form>
        <input class="form-control" name="text_to_uppercase" value="<%= @text %>"><br>
        <button class="btn btn-primary" id="uppercase_button" drab="click:uppercase">Upcase</button>
        <button class="btn btn-primary" id="lowercase_button" drab="click:lowercase">Downcase</button>
      </form>
    </p>
    </p>
  </div>
</div>
<hr>


<div class="row">
  <a name="poke">
    <h4 class="anchored">POKE and PEEK strike back</h4>
  </a>
  <div class="col-md-8">
    <p>
      Function <code>poke/2</code> is one of the most important in Drab, so we should go a little bit deeper. Let's assume you have your <code>index.html.eex</code> already prepared, displaying a list of some users. There are two assigns there, <code>@title</code> and <code>@users</code>:
<pre><code class="html">&lt;strong&gt;&lt;%= @title %&gt;:&lt;/strong&gt;&lt;br&gt;
&lt;%= for user &lt;- @users do %&gt;
  Username: &lt;%= user %&gt;&lt;br&gt;
&lt;% end %&gt;
</code></pre>
The code is rendered as usual, in the simple Controller:
<pre><code class="elixir">defmodule DrabPoc.LiveController do
  use DrabPoc.Web, :controller

  def index(conn, _params) do
    render conn, "index.html", users: ["Dżesika", "Brajanek", "Zdzichu"], title: "Users List"
  end
end
</code></pre>
    </p>
    <p>
      The goal of Drab is to update <code>assigns</code> live, without re-rendering the page. For this, <code>Drab</code> introduces its own <code>EEx Engine</code>. By default, it uses <code>.drab</code> extension, so you need to rename <code>index.html.eex</code> to <code>index.html.drab</code>.
    </p>
    <p>
      Then, create some button to launch the Drab event in the commander:
<pre><code class="html"><%=~s(<button drab-click="replace_list">Replace List</button>)%></code></pre>
    Did you notice <code>drab-click</code> attribute? This is an alternative method for defining handler for an event. There is a number of such shorthands for most popular events, see documentation for more.
    </p>
    <p>
      The event handler function should be placed inside the commander module. By default, Drab searches for the corresponding names, so pages generated with <code>DrabPoc.LiveController</code> are handled by <code>DrabPoc.LiveCommander</code>. Handler below simply replaces the users list with the new one:
<pre><code class="elixir"><%=~s/defmodule DrabPoc.LiveCommander do
  use Drab.Commander

  defhandler replace_list(socket, _sender) do
    Drab.Live.poke socket, users: ["Mścisław", "Bożydar", "Mściwój", "Bogumił", "Mirmił"]
  end
end/%></code></pre>
    What is going on here? We've just modified the assign <code>@users</code> with the new value. <code>Drab.Live.poke</code> pushes the new value and re-evaluate the corresponding part of the template. Notice that you don't have to <code>poke</code> all assigns, <strong>Drab</strong> remembers what was there previously, and replaces only the assigns you've poked (in this case, <code>@users</code>).
    </p>
    <p>
      The second button runs <code>replace_title</code> event handler, which changes the value of the <code>@title</code> assign:
<pre><code class="elixir"><%=~s/defhandler replace_title(socket, _sender) do
  Drab.Live.poke socket, title: "New, better Title"
end/%></code></pre>
    Of course you can change the values of many assigns in one <code>poke</code>, Drab will find and update the corresponding parts of the page.
    </p>
    <p>
      Last, but not least, is the possibility to get the current value of assigns. For this, we have a function called <code>peek/2</code>. In the example, the third button adds something to the existing list of users:
<pre><code class="elixir"><%=~s/defhandler add_to_list(socket, _sender) do
  users = Drab.Live.peek(socket, :users)
  Drab.Live.poke socket, users: users ++ ["Hegemon"]
end/%></code></pre>
    </p>
    <p>
      Notice that assign is updated only on the server side, with <code>poke/2</code>. This is why we didn't use <code>peek/2</code> in the first example - having <code>&lt;input value=&quot;&lt;%= @assign %&gt;&quot;</code> does not update <code>@assign</code> when user changes the input.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <strong><%= @title %>:</strong><br>
      <%= for user <- @users do %>
        Username: <%= user %> <br>
      <% end %>
    </p>
    <p>
      <br><br>
      <button class="btn btn-primary" drab-event="click" drab-handler="replace_list">Replace List</button>
      <br><br>
      <button class="btn btn-primary" drab-event="click" drab-handler="replace_title">Replace Title</button>
      <br><br>
      <button class="btn btn-primary" drab-event="click" drab-handler="add_to_list">Add to Existing List</button>
    </p>
  </div>

</div>
<hr>



<div class="row">
  <a name="long_running">
    <h4 class="anchored">Long Running Process with Live Attributes and Properties</h4>
  </a>
  <div class="col-md-8">
    <p>
      Let's move on to show how to update DOM node attributes and properties, live. At the same time, the next example is going to demonstrate what Drab is good in: controlling the user interface from the long-running server process. <br>
      Assume we have a process which is doing some stuff on the server side, and we want to report back to the user after each completed step. We are going to use the progress bar controlled from the server.
      <pre><code class="html">&lt;div class=&quot;progress&quot;&gt;
  &lt;div class=&quot;progress-bar &lt;%= @progress_bar_class %&gt;&quot; @style.width=&lt;%= &quot;#{@bar_width}%&quot; %&gt;&gt;
    &lt;%= &quot;#{@bar_width}%&quot; %&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;button class=&quot;btn btn-primary&quot; drab-click=&quot;perform_long_process&quot;&gt;&lt;%= @long_process_button_text %&gt;&lt;/button&gt;</code></pre>
      Notice that this time we used assigns in the DOM node attributes: <code>class</code> and <code>@style.width</code>. What will happen when we <code>poke</code> this assigns from the controller? In the first case, <code>class</code> <strong>attribute</strong> is updated as expected. In the second case, Drab sets <code>style.width</code> <strong>property</strong> of the corresponding node to whatever is <strong>evaluated of the given Elixir expression</strong>.
    </p>
    <p>
      We are going to live update the assigns of the template above from <code>perform_long_process/2</code> function in the commander:
      <pre><code class="elixir">defhandler perform_long_process(socket, _sender) do
  poke socket, progress_bar_class: &quot;progress-bar-danger&quot;,
    long_process_button_text: &quot;Processing...&quot;

  steps = :rand.uniform(100)
  for i &lt;- 1..steps do
    Process.sleep(:rand.uniform(500)) #simulate real work
    poke socket, bar_width: Float.round(i * 100 / steps, 2)
  end

  poke socket, progress_bar_class: &quot;progress-bar-success&quot;,
    long_process_button_text: &quot;Click me to restart&quot;
end</code></pre>
      This function simulates some process, which updates the User Interface after each step done. For more fun, we randomly choose the number of steps and the step "processing time".
    </p>
    <p>
      Before running loop of steps, we update the button text (to show the user that the work is in progress), and the progress bar <code>class</code> attribute. In the template, it was initially set to <code>class=&quot;progress-bar &lt;%= @progress_bar_class %&gt;&quot;</code>. After <em>poking</em> the <code>@progress_bar_class</code> assign, Drab updates the <code>class</code> attribute of the node, preserving the given pattern: it will become <code>class=&quot;progress-bar progress-bar-danger&quot;</code>.
    </p>
    <p>
      Even more interesting happens when <em>poking</em> the <code>@bar_width</code> assign. Using the <strong><code>@property=&lt;%= expression %&gt;</code> syntax</strong>, we can bound any node property with the Elixir expression! In this case, <code>@style.width=&lt;%= &quot;#{@bar_width}%&quot; %&gt;</code> connects <code>style.width</code> of the DOM object with <code>&quot;#{@bar_width}%&quot;</code> expression. Elixir expression is evaluated every time you <code>poke</code> a new value of the assign(s), and the value of the evaluated expression updates given node property.
    </p>
    <p>
      Unlike attributes, properties may be bound to any JSON encodable value: a list, a map, etc. And because of this, properties syntax does have some limitations. The only valid sytax is <code>@property=&lt;%= expression %&gt;</code>, no quotes or apostrophes. You can only bind one expression to one property; you may not use string patterns, like you could with attributes.
    </p>
    <p>
      One more thing: you probably noticed that when the task is "processing", you can click another button in the page. This is because <strong>Drab requests are asynchronous on the server side</strong>. And this is a reason why buttons are disabled by default while processing - it is blocking the user from running the same action for few times. You may override this behavior in `config.exs` with:
      <pre><code class="elixir"><%=~s/config :drab, disable_controls_while_processing: false/%></code></pre>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Click a button to simulate long-running process on the server.
      <div class="progress">
        <div class="progress-bar <%= @progress_bar_class %>" role="progressbar" @style.width=<%= "#{@bar_width}%" %>>
          <%= "#{@bar_width}%" %>
        </div>
      </div>
      <button class="btn btn-primary" drab-click="perform_long_process"><%= @long_process_button_text %></button>
    </p>
  </div>
</div>
<hr>




<div class="row">
  <a name="async_task">
    <h4 class="anchored">Tens of Tasks Running in Parallel on the Server and Communicating Back to the Browser</h4>
  </a>
  <div class="col-md-8">
    <p>
      In the next example we will emulate long running server Process composed of a number of Tasks, which can be run asynchronously. We want to run it in parallel, change their status when they finish the job and - when all of them are done - change the status of the whole process.
    </p>
    <p>
     The HTML side contains a button and a few spans to display the status of the process and tasks:
     <pre><code class="html">Async task status:
&lt;span id=&quot;async_task_status&quot; class=&quot;label label-primary&quot;&gt;
  &lt;%= @async_task_status %&gt;
&lt;/span&gt;
&lt;span class=&quot;task label label-danger&quot; task-id=&quot;1&quot;&gt;Task 1&lt;/span&gt;
  ...
&lt;span class=&quot;task label label-danger&quot; task-id=&quot;54&quot;&gt;Task 54&lt;/span&gt;
&lt;button drab-click=&quot;run_async_tasks&quot;&gt;Start async task&lt;/button&gt;</code></pre>
    </p>
    <p>
      All the processing is on the server side. Clicking the button runs the <code>run_async_tasks/2</code> function:
      <pre><code class="elixir">defhandler run_async_tasks(socket, _sender) do
  poke socket, async_task_label: &quot;danger&quot;, async_task_status: &quot;running&quot;
  set_attr(socket, &quot;.task[task-id]&quot;, class: &quot;task label label-danger&quot;)

  tasks = Enum.map(1..54, fn(i) -&gt; Task.async(fn -&gt;
      Process.sleep(:rand.uniform(4000)) # simulate real work
      set_prop(socket, &quot;.task[task-id='#{i}']&quot;, className: &quot;task label label-success&quot;)
    end)
  end)

  begin_at = :os.system_time(:millisecond)
  Enum.each(tasks, fn(task) -&gt; Task.await(task) end)
  end_at = :os.system_time(:millisecond)

  poke socket, async_task_label: &quot;success&quot;, async_task_status:
    &quot;finished in #{(end_at - begin_at)/1000} seconds&quot;
end</code></pre>
      The code above runs 54 tasks asynchronously, which just wait some time (up to 4 seconds) and then communicate to the user by changing the bootstrap class from <code>label-danger</code> to <code>label-success</code>. After launching the background tasks, it waits (<code>Task.await/1</code>) for all of the tasks to finish and then informs the user by changing the overall status to "finished".
    </p>
    <p>
      There are two new functions here: <code>set_attr/3</code> and <code>set_prop/3</code>. Both are members of <code>Drab.Element</code> module, which is the one for query and manipulate HTML element attributes and properties. They take the CSS selector as an argument, and modifies all the elements found by this selector.
    </p>
    <p>
      You may think: <b>what is the difference between this approach and running 54 AJAX requests which launches action on the controller side?</b> Well, in addition to <code>Drab</code>'s natural beauty, you can't do it with AJAX. You browser <a href="http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">limits the number of simultaneous connections</a>.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Click the button below to simulate server-side long running process with asynchronous tasks.
      <h4>Async task status: <span class="label label-<%= @async_task_label %>"><%= @async_task_status %></span></h4>
      <div class="row">
        <%= for i <- 1..54 do %>
          <div class="col-md-2 col-xs-4 centered">
            <span class="task label label-danger" task-id="<%= i %>">Task #<%= i |> Integer.to_string |> String.pad_leading(2, "0") %></span>
          </div>
        <% end %>
      </div>
      <br>
      <button class="btn btn-primary" drab-click="run_async_tasks">Start async task</button>
    </p>
  </div>
</div>
<hr>




<div class="row">
  <a name="tail_dash_f">
    <h4 class="anchored">Server-Side Events: Display the Growing File (tail -F)</h4>
  </a>
  <div class="col-md-8">
    <p>
      Another great example of Drab usage is to display the files, which are changing over the time, like log files. In the normal, Ajax world, you need to send a request periodically to refresh the view, and you never know, if the file changed or not. What a waste of resources!
    </p>
    <p>
      Let's create a space for the access log, and fill it up with some initial message:
      <pre><code class="html">&lt;pre&gt;&lt;code class=&quot;accesslog&quot;&gt;&lt;%= @access_log %&gt;&lt;/code&gt;&lt;/pre&gt;</code></pre>
    </p>
    <p>
      With Drab, you can utilize the events on the Server Side: in this case to use <code>fsevent</code> to trace the changes in the file. So you upgrade the UI view only in case when something really happened.
    </p>
    <p>
      To enable the Server-Side event watcher, we are going to introduce the Drab Callbacks. Callbacks are events launched automatically, when page is loaded, when browser reconnects or disconnects from the Server. To enable it you need to specify them in the Commander:
<pre><code class="elixir"><%=~s/use Drab.Commander
  onconnect :connected
  ...
end/%></code></pre>
      <code>onconnect</code> launches every time client connects to the server, so after first load, network crashes, server crashes etc. There is also <code>onload</code> callback, which runs only once and ignores disconnects.
    </p>
    <p>
      In the callback implementation we subscribe to <code>Sentix</code> file watcher (it is a wrapper around <code>fswatch</code> utility):
<pre><code class="elixir"><%=~s/def connected(socket) do
  # Sentix is already started within application supervisor
  Sentix.subscribe(:access_log)

  file_change_loop(socket, Application.get_env(:drab_poc, :watch_file))
end/%></code></pre>
      Watcher sends a message each time the file change. In this case we are going to update the <code>@access_log</code> assign to present the last few lines of the file.
<pre><code class="elixir"><%=~s/defp file_change_loop(socket, file_path) do
  receive do
    {_pid, {:fswatch, :file_event}, {^file_path, _opts}} ->
      socket |> poke(access_log: last_n_lines(file_path, 8))
  end
  file_change_loop(socket, file_path)
end/%></code></pre>
    </p>
    <p>
      There is also the <code>disconnect</code> callback, which runs every time browser disconnects from the server - close the browser, navigate away from the page, network issue, etc. Obviously there is no way to show it on the Demo page, as it operates when the page is not visible anymore.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      This is a realtime view of few last lines of the access.log of this page
      <pre><code id="log_file" class="accesslog"><%= @access_log %></code></pre>
    </p>
  </div>
</div>
<hr>


<div class="row">
  <a name="broadcast">
    <h4 class="anchored">Is Drab Quick Enough? Plus Broadcast</h4>
  </a>
  <div class="col-md-8">
    <p>
      You may concern about Drab performance - is it quick enough to handle events in the realtime? The best to find it out is to check with, lets say, the <code>keyup</code> event.
      <pre><code class="html">&lt;input drab-keyup=&quot;changed_input&quot; class=&quot;form-control&quot; data-update=&quot;#display_placeholder&quot;&gt;
&lt;div id=&quot;display_placeholder&quot;&gt;&lt;/div&gt;</code></pre>
      <pre><code class="elixir">defhandler changed_input(socket, sender) do
  broadcast_prop socket, sender[&quot;dataset&quot;][&quot;update&quot;], innerText: String.upcase(sender[&quot;value&quot;])
end</code></pre>
    </p>
    <p>
      Did you notice the new <code>broadcast_prop/3</code> function? This one works exactly like <code>set_prop/3</code>, but it <strong>broadcasts to all browsers</strong> on which the current page is opened. Open another browser window or even another browser and observe what is going on when you type in the field. <br>
      By default, broadcasts are sent to the displayers of the current page, but you may change this behavior by setting up <code>broadcasting</code> option in the Commander. For example, setting <code>broadcasting :same_controller</code> will send this <code>broadcast_prop</code> to all browsers which have opened the pages generated in the current controller.
    </p>
  </div>

  <div class="col-md-4 left-bordered">
    <p>
      Demonstration of <code>keyup</code> event:
      <input drab-keyup="changed_input" class="form-control" data-update="#display_placeholder">
      <div id="display_placeholder"></div>
    </p>
  </div>

  <div class="col-md-8">
    <p>
      In many situation you don't need to react on every single key press, and you want to launch the event when user stop typing. The good example is autocomplete - you don't want to search the database after each keypress. This is the are where <code>debounce()</code> option becomes handy:
      <pre><code class="html">&lt;input drab-keyup=&quot;changed_input&quot;
       drab-options=&quot;debounce(500)&quot;
       data-update=&quot;#display_placeholder2&quot;&gt;
&lt;div id=&quot;display_placeholder2&quot;&gt;&lt;/div&gt;</code></pre>
      The code above is exactly the same as previous, except of <code>debounce(500)</code> option. The same event handler (<code>changed_input/2</code>) is launched, but not after every key up, but when you actually stop typing for 500 miliseconds.
    </p>
  </div>
  <div class="col-md-4 left-bordered">
    <p>
      The same event with <code>debounce(500)</code>:
      <input id="debounce" drab-keyup="changed_input" drab-options="debounce(500)" data-update="#display_placeholder2" class="form-control">
      <div id="display_placeholder2"></div>
    </p>
  </div>

</div>
<hr>




<div class="row">
  <a name="argument">
    <h4 class="anchored">Optional Argument</h4>
  </a>

  <div class="col-md-8">
    To pass one additional argument to the event handler, just add it in the parenthesis after the handler function name:
    <p><pre><code class="html"><%=~S|<button class="btn btn-primary" drab-click="sleep(1)">Sleep 1 second</button><br>
<button class="btn btn-primary" drab-click="sleep(1+1)">Sleep 2 seconds</button><br>
<button class="btn btn-primary" drab-click="sleep(parseInt('3'))">Sleep 3 seconds</button>|%></code></pre>
    </p>
    <p>
      In this case, event handler must have arity of 3. Notice that the argument is evaluated on the client side before sending to the browser, so it can be any valid JS piece of code. In this example it is Integer, and it is passed to the Elixir function correctly, as Integer.
      <pre><code class="elixir"><%=~S/defhandler sleep(_socket, _sender, interval) do
  Process.sleep(interval * 1000)
end/%></code></pre>
      Observe that when one button is "processing", you can click another one. This is because <strong>Drab requests are asynchronous on the server side</strong>. And this is a reason why buttons are disabled by default while processing - it is blocking the user from running the same action for few times. You may override this behaviour, see documentation for <code>Drab.Config</code>.
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <button id="sleep_1_button" class="btn btn-primary" drab-click="sleep(1)">Sleep 1 second</button><br><br>
      <button id="sleep_2_button" class="btn btn-primary" drab-click="sleep(1 + 1)">Sleep 2 seconds</button><br><br>
      <button id="sleep_3_button" class="btn btn-primary" drab-click="sleep(parseInt('3'))">Sleep 3 seconds</button>
    </p>
  </div>
</div>
<hr>



<div class="row">
  <a name="shared">
    <h4 class="anchored">Shared Commanders</h4>
  </a>
  <div class="col-md-8">
    <p>
      So far, we did run events in the specific commander - the one which is related to the controller, which rendered the current page. This is done by the reason: we don't want to allow browser to launch any public function in our server! But it would be nice to run event handlers from another module, for staying DRY.
      Drab gives you an opportunity to do it with <b>Shared Commander</b>, just by specifying the module name in the drab attribute: <code>&lt;button drab-click=&quot;My.Module.function&quot;&gt;</code>.
      <br>
      We are going to create re-usable countdown commander, with two parameters: number of seconds to countdown from, and the selector of the node, on which the output will be displayed:
      <pre><code class="html"><%=~S|<button drab-click="DrabPoc.TimerCommander.countdown({seconds: 5, output: '#first_example'})">
  Count down from 5
</button>
<span id="first_example">SPAN #first_example</span>|%></code></pre>
    </p>
    <p>
      For the security reasons, you must declare all shared commanders you want to use, in the controller:
      <pre><code class="elixir"><%=~S/defmodule DrabPoc.LiveController do
  use Drab.Controller, commanders: [DrabPoc.TimerCommander]
end
/%></code></pre>
    </p>
    <p>
      The whole <code>TimerCommander</code> is simply the commander, with <code>countdown/3</code> event handler function:
      <pre><code class="elixir"><%=~S/defmodule DrabPoc.TimerCommander do
  use Drab.Commander

  defhandler countdown(socket, _sender, options) do
    for i <- 1..options["seconds"] do
      set_prop socket, options["output"], innerText: options["seconds"] - i
      Process.sleep(1000)
    end
  end
end
/%></code></pre>
      The handler function is getting a map, defined in the <code>drab-click</code> attribute in html, as a third argument.
    </p>

  </div>
  <div class="col-md-4">
    <p>
      <button class="btn btn-primary" drab-click="DrabPoc.TimerCommander.countdown({seconds: 5, output: '#first_example'})">
        Count down from 5
      </button>
      <br><span id="first_example">SPAN #first_example</span>
    </p>
  </div>

</div>
<hr>
<div class="row">
  <a name="components">
    <h4 class="anchored">Creating Reusable Components with Shared Commanders</h4>
  </a>

  <div class="col-md-8">
    <p>
      Now we are going to modify the example a bit. And this time, we are going to use <code>drab-commander</code> and <code>drab-argument</code> attributes. You may set them in any tag, and all the children of this tag will use given Shared Commander and the given argument:
      <pre><code class="html"><%=~S|<p drab-commander="DrabPoc.Timer2Commander" drab-argument="{seconds: 10}">
  <button class="btn btn-primary" drab-click="countdown">
    Count down from 10
  </button>
  <br><span class="output">SPAN .output</span>
</p>
<p drab-commander="DrabPoc.Timer2Commander" drab-argument="{seconds: 20}">
  <br>
  <button class="btn btn-primary" drab-click="countdown">
    Count down from 20
  </button>
  <br><span class="output">SPAN .output</span>
</p>|%></code></pre>
    </p>

    <p>
      Observe the example. When you click one of the buttons, the only corresponding <code>span.output</code> is updated. But how does Drab know which one to update? Here comes  function:
      <pre><code class="elixir"><%=~S/defmodule DrabPoc.Timer2Commander do
  use Drab.Commander

  defhandler countdown(socket, sender, options) do
    for i <- 1..options["seconds"] do
      set_prop socket, this_commander(sender) <> " .output", innerText: options["seconds"] - i
      Process.sleep(1000)
    end
  end
end/%></code></pre>
      <code>this_commander/1</code> function returns the unique selector of the tag with <code>drab-commander</code>. Using it, you may create reusable components.
    </p>


  </div>
  <div class="col-md-4">
    <p drab-commander="DrabPoc.Timer2Commander" drab-argument="{seconds: 10}">
      <button class="btn btn-primary" drab-click="countdown">
        Count down from 10
      </button>
      <br><span class="output">SPAN .output</span>
    </p>
    <p drab-commander="DrabPoc.Timer2Commander" drab-argument="{seconds: 20}">
      <br>
      <button class="btn btn-primary" drab-click="countdown">
        Count down from 20
      </button>
      <br><span class="output">SPAN .output</span>
    </p>
  </div>

</div>
<hr>

<div class="row">
  <a name="living_shared">
    <h4 class="anchored">Shared Commanders and Living Assigns</h4>
  </a>

  <div class="col-md-8">
    <p>
      The previous example was nice, but what about living assigns? They are using the pure magic to update the page, not the selector, so we can't use <code>this_commander/1</code> as above. Consider almost exactly the same html, but with the assigns:
      <pre><code class="html">&lt;p drab-commander=&quot;DrabPoc.Timer3Commander&quot; drab-argument=&quot;{seconds: 10}&quot;&gt;
  &lt;button class=&quot;btn btn-primary&quot; drab-click=&quot;countdown&quot;&gt;
    Count down from 10
  &lt;&#x2F;button&gt;
  &lt;br&gt;&lt;span &gt;&lt;%= @countdown %&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;p&gt;
&lt;p drab-commander=&quot;DrabPoc.Timer3Commander&quot; drab-argument=&quot;{seconds: 20}&quot;&gt;
  &lt;br&gt;
  &lt;button class=&quot;btn btn-primary&quot; drab-click=&quot;countdown&quot;&gt;
    Count down from 20
  &lt;&#x2F;button&gt;
  &lt;br&gt;&lt;span &gt;&lt;%= @countdown %&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;p&gt;</code></pre>
    </p>

    <p>
      What to do if we want to update the corresponding secion of the page with <code>poke</code>? The answer is: <b>nothing</b>. All is done automagically. Only the assigns, which are in the same <code>drab-commander</code> section as the element, which generated the event, are updated.
      <pre><code class="elixir"><%=~S/defmodule DrabPoc.Timer2Commander do
  use Drab.Commander

  defhandler countdown(socket, _sender, options) do
    for i <- 1..options["seconds"] do
      poke socket, countdown: options["seconds"] - i
    end
  end
end/%></code></pre>
      Notice in this handler we've removed <code>Process.sleep/1</code> - this is to demonstrate the network latency between the browser and the server.
    </p>


  </div>
  <div class="col-md-4">
    <p drab-commander="DrabPoc.Timer3Commander" drab-argument="{seconds: 10}">
      <button class="btn btn-primary" drab-click="countdown">
        Count down from 10
      </button>
      <br><span><%= @countdown %></span>
    </p>
    <p drab-commander="DrabPoc.Timer3Commander" drab-argument="{seconds: 20}">
      <br>
      <button class="btn btn-primary" drab-click="countdown">
        Count down from 20
      </button>
      <br><span><%= @countdown %></span>
    </p>
  </div>

</div>
<hr>



<div class="row">
  <a name="store">
    <h4 class="anchored">Drab Store and access to Plug Session</h4>
  </a>
  <div class="col-md-12">
    <p>
      Analogically to Plug, Drab can store the values in its own session. To avoid confusion with the session, we will call it a Drab Store. You can use two functions, <code>put_store/3</code> and <code>get_store/2</code> to read and write the values in the Store.
      <ul>
        <li>By default, Drab Store is kept in browser Local Storage. This means it is gone when you close the browser or the tab. You may set up where to keep the data with <code>drab_store_storage</code> config entry.</li>
        <li>Drab Store is not the Plug Session! This is a different entity. Anyway, you have an access to the Plug Session (details below).</li>
        <li>Drab Store is stored on the client side and it is signed, but - as the Plug Session cookie - not ciphered.</li>
      </ul>
    </p>
  </div>
  <div class="col-md-8">
    <p><pre><code class="elixir"><%=~S/defhandler increase_counter(socket, _sender) do
  counter = get_store(socket, :counter) || 0
  put_store(socket, :counter, counter + 1)
end

defhandler show_counter(socket, _sender) do
  poke socket, counter: get_store(socket, :counter)
end/%></code></pre>
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <button class="btn btn-primary" drab-click="increase_counter">Increase counter by 1</button><br><br>
      <button class="btn btn-primary" drab-click="show_counter">Show the counter value: <%= @counter %></button>
    </p>
  </div>

  <div class="col-md-8">
    <p>
    Although Drab Store is a different entity than Plug Session (used in Controllers), there is a way to access the Session. First, you need to whitelist the keys you want to access in <code>access_session/1</code> macro (you may give it a list of atoms or a single atom). Whitelisting is due to security: it is kept in Token, on the client side, so it is signed but not encrypted. <br>

    To show an example, we've put the key <code>:drab_test</code> to the Plug Session while rendering this page by the Controller:
    <pre><code class="elixir"><%=~S/defmodule DrabPoc.PageController do
  use DrabPoc.Web, :controller
  use Drab.Controller

  def index(conn, _params) do
    conn = put_session(conn, :drab_test, "test string in Plug Session, set in the Controller")
    render conn, "index.html"
  end
end/%></code></pre>
    To use it in the Commander, you need to explicitly inherit this value:
<pre><code class="elixir"><%=~S/defmodule DrabPoc.PageCommander do
  use Drab.Commander

  onload :page_loaded
  access_session :drab_test

  def page_loaded(socket) do
    set_prop socket, "#show_session_test", value: get_session(socket, :drab_test)
  end
end/%></code></pre>
    Notice that there is not way to update session from Drab. Session is read-only.
    </p>
  </div>
  <div class="col-md-4 left-bordered">
    <p>
      Result of <code>get_session(socket, :drab_test)</code> in the <code>onload</code> handler: <br>
      <input type="text" id="show_session_test" value="unknown..." class="form-control">
    </p>
  </div>

</div>
<hr>

<div class="row">
  <a name="chat_example">
    <h4 class="anchored">Chat Example</h4>
  </a>
  <div class="col-md-8">
    Is there any websocket based library without the Chat Example? Here is the one based on Drab! Simplest Chat Ever (and, well, the most primitive one). <br>
    The client-side contains a chat <code>div</code> to display messages, and two <code>input</code> fields - one for your nick, and the second one for the chat message:
    <p><pre><code class="html"><%=~S[<div id="chat" class="panel-body chat-panel"></div>
<input drab-change="update_nick" class="form-control" placeholder="nickname">
<input drab-change="update_chat" class="form-control">]%></code></pre>
    </p>

    <p>
      On the Elixir side, <code>update_nick</code> event handler saves your nickname for the future use:
      <pre><code class="elixir"><%=~S/defhandler update_nick(socket, sender), do: put_store(socket, :nickname, sender["value"])/%></code></pre>
    </p>
    <p>
      The following code is the whole chat application! We retrieve the nickname from the Drab Store (or set it to <i>Anonymous</i> if not found), compose the message to be displayed, and we are ready to go. First, we insert the message to the chat panel (used the <code>broadcast_insert</code> method with <code>:beforeend</code> modifier, so it is added at the bottom of the chat div). Second, clean up the message input. Third, scroll down chat to the bottom. All the changes of are broadcasted to all browsers viewing this page.
      <pre><code class="elixir">defhandler update_chat(socket, sender) do
  nick = get_store(socket, :nickname, &quot;Anonymous&quot;)
  html = ~E&quot;&lt;strong&gt;&lt;%= nick %&gt;:&lt;/strong&gt; &lt;%= message %&gt;&lt;br&gt;&quot; |&gt; safe_to_string()
  broadcast_insert socket, &quot;#chat&quot;, :beforeend, html
  set_prop socket, this(sender), value: &quot;&quot;
  broadcast_js socket, &quot;document.querySelector('#chat').scrollTop = document.querySelector('#chat').scrollHeight&quot;
end</code></pre>
      The only new thing is the <code>broadcast_js/2</code> function. As you probably guess, it runs any JS partial on all connected clients.
    </p>

    <p>So far, chat just displays the message when someone type it in. It would also nice to have some additional information, like the time when the message appeared. This is quite complicated feature - we can't just display the server time, as users may go from the different timezones. Drab has a build-in function <code>Drab.Browser.now/1</code> function, which gives the <strong>client local time</strong>:
      <pre><code class="elixir"><%=~S/iex> Drab.Browser.now(socket)
~N[2017-04-02 20:06:07.600000]
/%></code></pre>
    but we can't use it here, as we are broadcasting messages to all connected browsers, and every one may be in a different timezone.
    </p>
    <p>
      The solution is to use a bit of Javascript. Instead of adding the message to chat window with <code>broadcast_insert socket, "#chat", :beforeend, html</code>, we directly will run the JS on all connected browsers!
      <pre><code class="elixir">defp chat_message_js(message) do
  &quot;&quot;&quot;
  var time = &quot;[&quot; + (new Date()).toTimeString().substring(0, 5) + &quot;] &quot;
  document.querySelector('#chat').insertAdjacentHTML('beforeend', time + #{Drab.Core.encode_js(message)})
  &quot;&quot;&quot;
end

defp add_chat_message!(subject, message) do
  subject |&gt; broadcast_js(chat_message_js(message))
  subject |&gt; scroll_down!()
end

defhandler update_chat(socket, sender) do
  nick = get_store(socket, :nickname, &quot;Anonymous&quot;)
  html = ~E&quot;&lt;strong&gt;&lt;%= nick %&gt;:&lt;/strong&gt; &lt;%= message %&gt;&lt;br&gt;&quot; |&gt; safe_to_string()
  set_prop socket, this(sender), value: &quot;&quot;
  add_chat_message! socket, html
end</code></pre>
    </p>
  </div>

  <div class="col-md-4 left-bordered">

    <p>
      <div class="panel panel-default">
        <div class="panel-heading">The Chat</div>
        <div id="chat" class="panel-body chat-panel">
        </div>
        <div class="panel-footer">
          <div class="row">
            <div class="col-xs-3 no-right-padding">
              <input id="nickname" drab-change="update_nick" class="form-control no-right-radius" placeholder="nickname">
            </div>
            <div class="col-xs-9 no-left-padding">
              <input drab-change="update_chat" class="form-control no-left-radius">
            </div>
          </div>
        </div>
      </div>
    </p>

  </div>
</div>
<hr>

<div class="row">
  <a name="presence">
    <h4 class="anchored">Tracking connected users with Drab callbacks</h4>
  </a>
  <div class="col-md-8">

    <p>
      You probably realized that actual chat is a little bit more complicated then it was explained in the previous example. It shows users connects and disconnects, as well as the list of connected users (type in <code>/who</code> in the chat to see the list). To archive it, we are going to use Drab callbacks, defined with <code>onconnect/1</code> and <code>ondisconnect/1</code> macros. Again, please treat it only as an example of Drab features - there are better ways to tracking the presence in Phoenix.
      <pre><code class="elixir">def connected(socket) do
  nickname = get_store(socket, :nickname, &quot;Anonymous&quot;)
  joined = ~E&quot;&quot;&quot;
    &lt;span class='chat-system-message'&gt;*** &lt;b&gt;&lt;%= nickname %&gt;&lt;/b&gt; has joined the chat.&lt;/span&gt;&lt;br&gt;
    &quot;&quot;&quot; |&gt; safe_to_string()
  socket |&gt; add_chat_message!(joined)

  ref = make_ref()
  DrabPoc.Presence.add_user(ref, nickname)
  put_store(socket, :my_drab_ref, ref)
end</code></pre>
    The code above is executed every time your browser connects to the server. First, we broadcasts the information to all to show them that some has joined the chat. Second, we store the information about connected user in the special store, <code>DrabPoc.Presence</code>. It is just a simple <code>Agent</code>, which stores key/value pairs. It is out of the scope of this tutorial, but if you are interested how it works, read <a href="https://github.com/grych/drab-poc/blob/master/lib/drab_poc/presence.ex">the friendly source</a>.
    </p>
    <p>
      We are going to use a reference as a key, which will be stored on the client side with the Drab Store. We are going to need it while handling disconnects.
    </p>
    <p>
      Let's move to the disconnect handler. As you can probably guess, it is executed when the browser disconnects from the server. It may be because of navigating away from the page, close the tab or because of the network issues. Disconnect handler is different than the others - it does not receive the <code>socket</code> as an argument. It is because the <code>socket</code> does not exist anymore! But we still have an access to Drab Store and Drab Session:
      <pre><code class="elixir">def disconnected(store, session) do
  DrabPoc.Presence.remove_user(store[:my_drab_ref])
  removed_user = store[:nickname] || anon_with_country_code(session[:country_code])
  html = ~E&quot;&lt;%= removed_user %&gt; has left.&quot; |&gt; safe_to_string()
  add_chat_message!(same_controller(DrabPoc.PageController), html)
  update_presence_list!(same_controller(DrabPoc.PageController))
end</code></pre>
      We are going to use the Drab Store to retrieve the user's nickname, and the Drab process PID (remember, it was set previously in <code>onconnect</code> handler). First, we need to remove the connection information from the presence list. We could finish here, but it would be good to inform all other users that this person is gone. But how to broadcast the message, when the <code>socket</code> does not exist anymore?
    </p>
    <p>
      Drab's <strong>broadcasting functions can live without socket</strong>. Socket is needed only to find out to which browser send a message (so event handlers in Commander know which browser pressed a button). Broadcasts are just pushed into the void and being received by all the browsers which currently listen to the given topic. Because we set up the commander with <code>broadcasting :same_controller</code>, we can send the broadcast to <code>same_controller(Controller.Name)</code> instead of the socket.
    </p>
    <p>
      As a bonus, we've got the list of connected users. Let's use it and do a live list of all the people currently connected to this page. First, create a function to update the panel on the right:
      <pre><code class="elixir">defp update_presence_list!(socket_or_subject) do
  users = DrabPoc.Presence.get_users()
    |&gt; Map.values()
    |&gt; Enum.sort()
    |&gt; Enum.map(&amp;html_escape/1)
    |&gt; Enum.map(&amp;safe_to_string/1)
    |&gt; Enum.join(&quot;&lt;br&gt;&quot;)
  broadcast_prop socket_or_subject, &quot;#presence-list&quot;, innerHTML: users
end</code></pre>
      Second, run this function on connect, disconnect or nickname change. Voila!
    </p>

  </div>

  <div class="col-md-4 left-bordered">
    <p>
      <div class="panel panel-default">
        <div class="panel-heading">Connected users</div>
        <div id="presence-list" class="panel-body chat-panel">
        </div>
      </div>
    </p>
  </div>
</div>
<hr>

<div class="row">
  <a name="waiter">
    <h4 class="anchored">Drab Waiter</h4>
  </a>
  <div class="col-md-12">
    <p>
      Sometimes it would be good to have the possibility to ask user about something, when you are in a middle of some process, and you don't want to finish your function. The good example is a <strong>database transaction, when you run some query and want to ask user whether commit or rollback changes</strong>.
    </p>
    <p>
      So the solution for this issue is called <strong>Drab Waiter</strong>. It is a tiny little DSL which stops processing the event handler function and waits for some event from the client side. You may register multiple events as well as a timeout (by default it is waiting forever). The example below is not very sophisticated, but shows the idea.
    </p>
  </div>
  <div class="col-md-8">
    <p><pre><code class="elixir"><%=~S/defhandler waiter_example(socket, _sender) do
  buttons = render_to_string("waiter_example.html", [])

  set_prop socket, "#waiter_answer_div", innerHTML: nil
  insert_html socket, "#waiter_example_div", :beforeend, buttons

  answer = waiter(socket) do
    on "#waiter_example_div button", "click", fn(sender) ->
      sender["text"]
    end
    on_timeout 5500, fn ->
      "six times nine"
    end
  end

  set_prop socket, "#waiter_example_div", innerHTML: nil
  set_prop socket, "#waiter_answer_div", innerText: "Do you really think it is #{answer}?"
end/%></code></pre>
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <button class="btn btn-primary" drab-click="waiter_example">Waiter Example</button>
      <br><br>
      <div id="waiter_answer_div"></div>
      <div id="waiter_example_div"></div>
    </p>
  </div>

</div>
<hr>

<div class="row">
  <a name="errors">
    <h4 class="anchored">Handling Errors and Exceptions</h4>
  </a>
  <div class="col-md-12">
    <p>
      Drab intercepts all exceptions from the event handler function and lets them die, but before it presents the error message in the logs, and, for development environment, on the page. For production, it shows just an alert with the generic error.<br>
      Please notice that an error in the specific handler function will not harm anything else: all the processing are going on normally.
    </p>
  </div>
  <div class="col-md-8">
    <p>
    <pre><code class="elixir"><%=~S|defhandler raise_error(_socket, _dom_sender) do
  map = %{x: 1, y: 2}
  # the following line will cause KeyError
  map.z
end|%></code></pre>
    By default it is just an <code>alert()</code>, but you can easly override it by creating the template in <code>priv/templates/drab/drab.error_handler.js</code> with your own javascript presenting the error.
    </p>
    <p>
    There is a very descriptive message in the logs. The same message is shown within the alert on development environment.
    <pre><code class="text"><%=~S|[error] Drab Handler failed with the following exception:
** (KeyError) key :z not found in: %{x: 1, y: 2}
    (drab_poc) web/commanders/live_commander.ex:200: DrabPoc.LiveCommander.raise_error/2
    (drab) lib/drab.ex:251: anonymous fn/6 in Drab.handle_event/6|%></code></pre>
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <button class="btn btn-primary" drab-click="raise_error">KABOOM!</button>
    </p>
  </div>

  <div class="col-md-8">
    <p>
    But what when the Handler Process is killed for some reason, other than the exception, - like being brutally murdered? The story is quite similar - we can show the error banner, but in this case there is no way to clean up. In practice the button will stay disabled.
    <pre><code class="elixir"><%=~S|defhandler self_kill(_socket, _dom_sender) do
  Process.exit(self(), :kill)
end|%></code></pre>
    </p>
  </div>
  <div class="col-md-4">
    <p>
      <button class="btn btn-primary" drab-click="self_kill">Commit Suicide</button>
    </p>
  </div>
</div>
<hr>

<div class="row">
  <a name="debugging">
    <h4 class="anchored">Debugging</h4>
  </a>
  <div class="col-md-12">
    <p>
      There is an easy way to check and debug Drab functions directly in the <code>IEx</code>. The only thing you need to do is to run your Drab-enabled Phoenix server (you can get one with pre-installed Phoenix and Drab from <a href="https://github.com/grych/drab-example">https://github.com/grych/drab-example</a>) with IEx: <code>iex -S mix phoenix.server</code>. Then, connect with the browser to <code>http://localhost:4000</code> and observe the IEx console. When started, Drab will show you some important debugging information:
      <pre><code class="text">[debug]
    Started Drab for controller:Elixir.DrabPoc.LiveController, handling events in DrabPoc.LiveCommander
    You may debug Drab functions in IEx by copy/paste the following:
import Drab.{Core, Waiter, Element, Live}
socket = Drab.get_socket(pid(&quot;0.753.0&quot;))

    Examples:
socket |&gt; exec_js(&quot;alert('hello from IEx!')&quot;)
socket |&gt; poke(count: 42)</code></pre>
    </p>
    <p>
      As suggested, copy those two lines into IEx and now you can remote control your browser from IEx. Very handy for learning Drab and debugging!
      <pre><code class="elixir">iex(1)> import Drab.{Core, Waiter, Element, Live}
[Drab.Core, Drab.Waiter, Drab.Element, Drab.Live]
iex(2)> socket = Drab.get_socket(pid("0.879.0"))
%Phoenix.Socket{assigns: %{__action: :index,
  ...
transport_pid: #PID<0.876.0>}
iex(3)> query socket, "#uppercase_button", [:text, :className]
{:ok, %{"#uppercase_button" => %{"className" => "btn btn-primary"}}}
iex(4)> set_style socket, "p", backgroundColor: "red"
{:ok, 147}
</code></pre>
    </p>
    <p>
      Please be aware that Drab creates its own process for every single connection, so if you open a page in multiple tabs or browsers, you will have to handle with few different Drab PIDs. Also watch out for automatic page reload after code change - this will re-launch Drab as well, and it will change its PID.
    </p>
  </div>
</div>
<hr>

<h4>
  &copy;2016 - 2017 Tomek "Grych" Gryszkiewicz, <a href="mailto:grych@tg.pl">grych@tg.pl</a>
</h4>
<hr>
<p>
  Warning: <b>this is still a beta version</b>. Any comments, criticism, thoughts are welcome - <a href="mailto:grych@tg.pl?Subject=Drab">grych@tg.pl</a>. Your feedback is highly appreciated!
</p>
<hr>
<p>
  Illustrations by <a rel="nofollow" href="https://www.vecteezy.com">www.Vecteezy.com</a>
</p>
